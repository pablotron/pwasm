#define _GNU_SOURCE
#include <stdbool.h> // bool
#include <stdio.h> // snprintf()
#include <sys/mman.h> // mprotect
#include "pwasm-dynasm-jit.h"
#include <dlfcn.h> // dlsym()

// FIXME: do i need this any more?
static int32_t pwasm_dynasm_jit_get_extern(const uint8_t *, unsigned int, int);
#define DASM_EXTERN(ctx, addr, idx, type) \
  pwasm_dynasm_jit_get_extern(addr, idx, type)

#include <dynasm/dasm_proto.h>
#include <dynasm/dasm_x86.h>

#ifdef PWASM_DEBUG
#include "pwasm-dump.h"
#define D(fmt, ...) fprintf( \
  stderr, \
  "D %s:%d %s(): " fmt "\n", \
  __FILE__, __LINE__, __func__, __VA_ARGS__ \
)
#else
#define D(fmt, ...)
#endif /* PWASM_DEBUG */

|.arch x64
|.actionlist actions
|.globals lbl_
|.externnames externs

// internal jit data
typedef struct {
  uint64_t flags;
} pwasm_dynasm_jit_t;

// function args
// sysv amd64 calling convention
// (https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions)
|.define r_arg0, rdi
|.define r_arg1, rsi
|.define r_arg2, rdx
|.define r_arg3, rcx
|.define r_arg4, r8
|.define r_arg5, r9
|.define r_arg2d, edx
|.define r_arg3d, ecx
|.define r_arg4d, r8d
|.define r_arg5d, r9d

// pointer to base and tail of stack
|.define r_env, r12
|.define r_base, r13
|.define r_stack, r14

// TODO
|.macro save_regs
  | sub rsp, 8
  | push r12
  | push r13
  | push r14
|.endmacro

// TODO
|.macro restore_regs
  | pop r14
  | pop r13
  | pop r12
  | add rsp, 8
|.endmacro

| .macro callp, addr
  | mov64 rax, (uintptr_t) addr
  | call rax
| .endmacro

|.macro stack_inc
  | add r_stack, sizeof(pwasm_val_t)
|.endmacro

|.macro stack_dec
  | sub r_stack, sizeof(pwasm_val_t)
|.endmacro

|.macro stack_decn, num
  | sub r_stack, (num * sizeof(pwasm_val_t))
|.endmacro

|.macro stack_save_depth
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | mov rax, [rax + offsetof(pwasm_stack_t, ptr)]
  | mov rbx, r_stack
  | sub rbx, rax
  | shr rbx, 4
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | mov [rax + offsetof(pwasm_stack_t, pos)], rbx
|.endmacro

|.macro stack_reg_init
  // load stack pointer
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | mov r_stack, [rax + offsetof(pwasm_stack_t, ptr)]

  // get stack offset
  | mov rbx, [rax + offsetof(pwasm_stack_t, pos)]
  | shl rbx, 4

  // increment stack pointer
  | add r_stack, rbx
|.endmacro

|.macro i32_testop_init
  | mov eax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i32_testop_fini
  | mov eax, 0
  | sete al
  | mov [r_stack - sizeof(pwasm_val_t)], eax
|.endmacro

|.macro i32_unop_init
  | mov eax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i32_unop_fini
  | mov [r_stack - sizeof(pwasm_val_t)], eax
|.endmacro

|.macro i32_relop_init
  | mov eax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov ebx, [r_stack - sizeof(pwasm_val_t)]
  | cmp eax, ebx
  | mov eax, 0
|.endmacro

|.macro i32_relop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
  | stack_dec
|.endmacro

|.macro i32_binop_init
  | mov eax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov ebx, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i32_binop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
  | stack_dec
|.endmacro

|.macro i64_testop_init
  | mov rax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i64_testop_fini
  | mov eax, 0
  | sete al
  | mov [r_stack - sizeof(pwasm_val_t)], eax
|.endmacro

|.macro i64_unop_init
  | mov rax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i64_unop_fini
  | mov [r_stack - sizeof(pwasm_val_t)], rax
|.endmacro

|.macro i64_relop_init
  | mov rax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov rbx, [r_stack - sizeof(pwasm_val_t)]
  | cmp rax, rbx
  | mov eax, 0
|.endmacro

|.macro i64_relop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
  | stack_dec
|.endmacro

|.macro i64_binop_init
  | mov rax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov rbx, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i64_binop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], rax
  | stack_dec
|.endmacro

|.macro f32_unop_init
  | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f32_unop_fini
  | movss dword [r_stack - sizeof(pwasm_val_t)], xmm0
|.endmacro

|.macro f32_relop_init
  | movd xmm0, dword [r_stack - 2 * sizeof(pwasm_val_t)]
  | movd xmm1, dword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f32_relop_fini
  | psrld xmm0, 31
  | movd dword [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

|.macro f32_binop_init
  | movss xmm0, dword [r_stack - 2 * sizeof(pwasm_val_t)]
  | movss xmm1, dword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f32_binop_fini
  | movss dword [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

|.macro f64_unop_init
  | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f64_unop_fini
  | movsd qword [r_stack - sizeof(pwasm_val_t)], xmm0
|.endmacro

|.macro f64_relop_init
  | movq xmm0, qword [r_stack - 2 * sizeof(pwasm_val_t)]
  | movq xmm1, qword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f64_relop_fini
  | psrld xmm0, 31
  | movd dword [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

|.macro f64_binop_init
  | movsd xmm0, qword [r_stack - 2 * sizeof(pwasm_val_t)]
  | movsd xmm1, qword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f64_binop_fini
  | movsd qword [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

|.macro v128_unop_init
  // FIXME: use movdqu, movups, or lddqu here?
  | movdqu xmm0, [r_stack - sizeof(pwasm_val_t)]
  // | lddqu xmm0, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro v128_unop_fini
  | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0
|.endmacro

|.macro v128_binop_init
  // FIXME: use movups or lddqu here?
  | movdqu xmm0, [r_stack - 2 * sizeof(pwasm_val_t)]
  | movdqu xmm1, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

// load operands in reverse order
// (e.g. xmm0 = stack[-1], xmm1 = stack[-2]
|.macro v128_inv_binop_init
  | movdqu xmm0, [r_stack - sizeof(pwasm_val_t)]
  | movdqu xmm1, [r_stack - 2 * sizeof(pwasm_val_t)]
|.endmacro

|.macro v128_r32_binop_init
  | movdqu xmm0, [r_stack - 2 * sizeof(pwasm_val_t)]
  | movd xmm1, dword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro v128_binop_fini
  | movdqu [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

// load value from memory and place it at the top of the stack.
// this macro assumes the top of the stack contains an i32 offset
// operand, which is popped and replaced with the loaded value.
//
// this macro calls pwasm_dynasm_jit_mem_load(), which is a convenience
// shim around pwasm_env_mem_load().
|.macro mem_load
  | save_regs                         // push regs

  // populate parameters (sysv x86-64 abi)
  | mov r_arg0, r_env                 // env ptr
  | mov r_arg1, 1                     // mem_id (FIXME, hard-coded)
  | mov r_arg2, in.op                 // opcode
  | mov r_arg3d, in.v_mem.offset      // offset immediate
  | mov r_arg4d, in.v_mem.align       // align immediate
  | mov r_arg5, r_stack               // stack ptr
  | sub r_arg5, sizeof(pwasm_val_t)   // point at tail of stack

  // call pwasm_dynasm_jit_mem_load
  | mov64 rax, (uintptr_t) pwasm_dynasm_jit_mem_load
  | call rax                          // call
  | restore_regs                      // restore regs

  // check for error
  | cmp eax, 0
  | je ->exit_failure
|.endmacro

/**
 * Call error handler.
 */
static void
fail(
  pwasm_env_t * const env,
  const char * const text
) {
  D("%s", text);
  pwasm_fail(env->mem_ctx, text);
}

static int32_t
pwasm_dynasm_jit_get_extern(
  const uint8_t * const addr,
  const unsigned int idx,
  const int type
) {
  const void *dst_addr = dlsym(RTLD_DEFAULT, externs[idx]);
  if (type) {
    return ((unsigned char*) dst_addr - (addr) - sizeof(int32_t));
  } else {
    const union {
      int32_t i32;
      unsigned char *ptr;
    } val = { .ptr = (unsigned char *) dst_addr };
    return val.i32;
  }
}

/**
 * Load value from memory.
 *
 * This is a shim function to make calling pwasm_env_mem_load() from
 * DynASM slightly easier.
 */
static bool
pwasm_dynasm_jit_mem_load(
  pwasm_env_t * const env,
  const uint32_t mem_id,
  const pwasm_op_t op,
  const uint32_t offset_imm,
  const uint32_t align_imm,
  pwasm_val_t * const val
) {
  // pop offset operand from stack
  const uint32_t ofs = val->i32;

  // synthesize instruction from opcode and offset immediate
  const pwasm_inst_t in = {
    .op = op,
    .v_mem = {
      .offset = offset_imm,
      .align = align_imm,
    },
  };

  return pwasm_env_mem_load(env, mem_id, in, ofs, val);
}

/**
 * Store value to memory.
 *
 * This is a shim function to make calling pwasm_env_mem_store() from
 * DynASM slightly easier.
 */
static bool
pwasm_dynasm_jit_mem_store(
  pwasm_env_t * const env,
  const uint32_t mem_id,
  const pwasm_op_t op,
  const uint32_t offset_imm,
  const uint32_t align_imm,
  pwasm_val_t * const vals
) {
  // pop offset operand from stack
  const uint32_t ofs = vals[0].i32;

  // synthesize instruction from opcode and offset immediate
  const pwasm_inst_t in = {
    .op = op,
    .v_mem = {
      .offset = offset_imm,
      .align = align_imm,
    },
  };

  return pwasm_env_mem_store(env, mem_id, in, ofs, vals[1]);
}

/**
 * Verify type, then call function indirectly.
 */
static bool
pwasm_dynasm_jit_call_indirect(
  pwasm_env_t * const env,
  const uint32_t mod_id,
  const uint32_t table_id,
  const uint32_t imm_type,
  const uint32_t elem_ofs
) {
  // get element value, check for error
  uint32_t func_ofs;
  if (!pwasm_env_get_elem(env, table_id, elem_ofs, &func_ofs)) {
    // return failure
    return false;
  }

  // get parsed module, check for error
  const pwasm_mod_t *mod = pwasm_env_get_mod(env, mod_id);
  if (!mod) {
    // return failure
    return false;
  }

  // get function type
  const uint32_t func_type = mod->funcs[func_ofs];
  // D("imm_type = %u, func_type = %u", imm_type, func_type);

  // compare types, check for error
  bool same;
  if (!pwasm_block_type_compare(mod, imm_type, func_type, &same)) {
    // return failure
    return false;
  }

  // check comparison result
  if (!same) {
    // log error, return failure
    fail(env, "call_indirect: function type mismatch");
    return false;
  }

  // call function, return result
  return pwasm_env_call_func(env, mod_id, func_ofs);
}

//
// control stack: used by compiler to manage control frames
//

// control stack entry types
#define CTRL_TYPES \
  CTRL_TYPE(BLOCK) \
  CTRL_TYPE(LOOP) \
  CTRL_TYPE(IF) \
  CTRL_TYPE(ELSE)

// control stack entry types
typedef enum {
#define CTRL_TYPE(a) CTRL_ ## a,
CTRL_TYPES
#undef CTRL_TYPE
  CTRL_LAST,
} pwasm_ctrl_stack_entry_type_t;

// control stack entry
typedef struct {
  pwasm_ctrl_stack_entry_type_t type; // entry type
  int32_t block_type; // block type
  size_t label;
} pwasm_ctrl_stack_entry_t;

// control stack
typedef struct {
  // vector of entries
  pwasm_vec_t stack;
} pwasm_ctrl_stack_t;

/**
 * Initialize control stack.
 *
 * Returns `true` on success or `false` on error.
 */
static bool
pwasm_ctrl_stack_init(
  pwasm_ctrl_stack_t * const stack,
  pwasm_mem_ctx_t * const mem_ctx
) {
  const size_t stride = sizeof(pwasm_ctrl_stack_entry_t);
  return pwasm_vec_init(mem_ctx, &(stack->stack), stride);
}

/**
 * Finalize control stack.
 */
static void
pwasm_ctrl_stack_fini(
  pwasm_ctrl_stack_t * const stack
) {
  pwasm_vec_fini(&(stack->stack));
}

#if 0
static size_t
pwasm_ctrl_stack_get_size(
  const pwasm_ctrl_stack_t * const stack
) {
  return pwasm_vec_get_size(&(stack->stack));
}
#endif /* 0 */

static const void *
pwasm_ctrl_stack_peek_tail(
  const pwasm_ctrl_stack_t * const stack,
  const size_t ofs
) {
  return pwasm_vec_peek_tail(&(stack->stack), ofs);
}

/**
 * Remove tail entry from control stack.
 *
 * Returns `false` if an error occurred.
 */
static bool
pwasm_ctrl_stack_pop(
  pwasm_ctrl_stack_t * const stack,
  pwasm_ctrl_stack_entry_t * const dst
) {
  // pop final entry, return result
  return pwasm_vec_pop(&(stack->stack), dst);
}

/**
 * Append entry to tail of control stack.
 *
 * Returns `false` if an error occurred.
 */
static bool
pwasm_ctrl_stack_push(
  pwasm_ctrl_stack_t * const stack,
  const pwasm_ctrl_stack_entry_t entry
) {
  return pwasm_vec_push(&(stack->stack), 1, &entry, NULL);
}

/**
 * Compile the given module function and then populate the given
 * destination buffer with the length of the generated code and a
 * pointer to the start of the function.
 *
 * Returns `true` on success, or `false` if an error occurred.
 */
static bool
pwasm_dynasm_jit_on_compile(
  pwasm_jit_t * const jit,
  pwasm_buf_t * const dst,
  pwasm_env_t *env,
  const uint32_t mod_id,
  const size_t func_ofs
) {
  const pwasm_mod_t * const mod = pwasm_env_get_mod(env, mod_id);
  // const pwasm_type_t type = mod->types[mod->funcs[func_ofs]];
  const pwasm_func_t func = mod->codes[func_ofs];
  const pwasm_inst_t * const insts = mod->insts + func.expr.ofs;
  (void) jit;

  // init control stack
  size_t ctrl_depth = 0;
  pwasm_ctrl_stack_t ctrl_stack;
  if (!pwasm_ctrl_stack_init(&ctrl_stack, env->mem_ctx)) {
    fail(env, "ctrl_stack_init failed");
    return false;
  }

  // init jit
  void *labels[lbl__MAX];
  dasm_State *dasm;
  D("dasm_init(%u)", 1);
  dasm_init(&dasm, 1);
  dasm_setupglobal(&dasm, labels, lbl__MAX);
  dasm_setup(&dasm, actions);
  dasm_growpc(&dasm, 100); // FIXME

  dasm_State** Dst = &dasm;
  | ->enter:
  // get env pointer
  | mov r_env, r_arg0

  // init stack register, cache stack base
  | stack_reg_init
  | mov r_base, r_stack

  size_t max_label = 0;
  for (size_t i = 0; i < func.expr.len; i++) {
    const pwasm_inst_t in = insts[i];
    switch (in.op) {
    case PWASM_OP_I32_CONST:
      D("0x%02X %s (0x%08x)", in.op, pwasm_op_get_name(in.op), in.v_i32);
      break;
    default:
      D("0x%02X %s", in.op, pwasm_op_get_name(in.op));
    }

    switch (in.op) {
    case PWASM_OP_UNREACHABLE:
      {
        // error message
        static const char * const text = "unreachable";

        // set parameters
        | mov64 r_arg0, (uintptr_t) env
        | mov64 r_arg1, (uintptr_t) text

        // call function
        | mov64 rax, (uintptr_t) fail
        | call rax

        // return failure
        | jmp ->exit_failure
      }
      break;
    case PWASM_OP_NOP:
      | nop
      break;
    case PWASM_OP_BLOCK:
      {
        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "block: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // decriment stack (block parameters)
          | stack_decn num_params
        }

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_BLOCK,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "block: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label++;
        dasm_growpc(&dasm, max_label);
      }

      break;
    case PWASM_OP_LOOP:
      {
        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "loop: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // decriment stack (block parameters)
          | stack_decn num_params
        }

        // emit label
        |=>max_label:

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_LOOP,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "loop: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label++;
        dasm_growpc(&dasm, max_label);
      }

      break;
    case PWASM_OP_IF:
      {
        // emit condition pop
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | stack_dec

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_IF,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "if: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label += 2;
        dasm_growpc(&dasm, max_label);

        // emit compare
        | cmp eax, 0
        | je =>entry.label

        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "if: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // emit stack pop (block parameters)
          D("num_params = %zu", num_params);
          // FIXME?
          // | stack_decn num_params
        }
      }

      break;
    case PWASM_OP_ELSE:
      {
        // pop if entry, check for error
        pwasm_ctrl_stack_entry_t if_entry;
        if (!pwasm_ctrl_stack_pop(&ctrl_stack, &if_entry)) {
          fail(env, "else: ctrl_stack_pop failed");
          return false;
        }

        // decriment control depth
        // disabled, redundant
        // ctrl_depth--;

        // emit unconditional jump to end
        | jmp =>(if_entry.label + 1)
        // emit else label
        | =>(if_entry.label):

        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, if_entry.block_type, &num_params)) {
          // log error, return failure
          fail(env, "if: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // emit stack pop (block parameters)
          D("num_params = %zu", num_params);
          | stack_decn num_params
        }

        // create control stack entry
        const pwasm_ctrl_stack_entry_t else_entry = {
          .type       = CTRL_ELSE,
          .block_type = if_entry.block_type,
          .label      = if_entry.label + 1,
        };

        // push else entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, else_entry)) {
          fail(env, "else: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        // disabled, redundant
        // ctrl_depth++;
      }

      break;
    case PWASM_OP_END:
      if (ctrl_depth > 0) {
        // pop control stack, check for error
        pwasm_ctrl_stack_entry_t tail;
        if (!pwasm_ctrl_stack_pop(&ctrl_stack, &tail)) {
          fail(env, "ctrl_stack_pop failed");
          return false;
        }

        // decriment depth
        ctrl_depth--;

        switch (tail.type) {
        case CTRL_IF:
          // emit tail labels
          // FIXME: is this right?
          | =>(tail.label):
          | =>(tail.label + 1):
          break;
        case CTRL_ELSE:
        case CTRL_BLOCK:
          // emit tail label
          | =>(tail.label):
          break;
        case CTRL_LOOP:
          // do nothing
          break;
        default:
          {
            // log error
            char buf[512];
            snprintf(buf, sizeof(buf), "unknown ctrl stack entry type: %u", tail.type);
            fail(env, buf);

            // return failure
            return false;
          }
        }

        // get block type result count, check for error
        size_t num_results;
        if (!pwasm_block_type_results_get_size(mod, tail.block_type, &num_results)) {
          // log error, return failure
          fail(env, "end: get block num_results failed");
          return false;
        }

        // pop results
        // TODO
//         for (size_t j = 0; j < num_results; j++) {
//           // calculate stack source and destination offsets
//           const size_t src_ofs = stack->pos - 1 - (num_results - 1 - j);
//           const size_t dst_ofs = ctrl_tail.depth + j;
//           stack->ptr[dst_ofs] = stack->ptr[src_ofs];
//         }
      } else {
        // emit exit success
        | jmp ->exit_success
      }

      break;
    case PWASM_OP_BR:
      if ((ctrl_depth > 0) && (ctrl_depth - in.v_index) > 0) {
        // get control stack tail, check for error
        const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, in.v_index);
        if (!tail) {
          fail(env, "br: ctrl_stack_peek_tail failed");
          return false;
        }

        // get destination label
        const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

        // emit jump to label
        | jmp =>label
      } else {
        // emit exit success
        | jmp ->exit_success
      }

      break;
    case PWASM_OP_BR_IF:
      // emit compare
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | stack_dec
      | cmp eax, 0

      if ((ctrl_depth > 0) && (ctrl_depth - in.v_index) > 0) {
        // get control stack tail, check for error
        const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, in.v_index);
        if (!tail) {
          fail(env, "br: ctrl_stack_peek_tail failed");
          return false;
        }

        // get destination label
        const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

        // emit jump to label
        | je =>label
      } else {
        // emit exit success
        | je ->exit_success
      }

      break;
    case PWASM_OP_BR_TABLE:
      {
        // get branch labels
        const pwasm_slice_t labels = in.v_br_table;

        // pop index
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | stack_dec

        // emit labels
        // FIXME: this could be optimized into a jump table
        for (size_t j = 0; j < labels.len - 1; j++) {
          const uint32_t ofs = mod->u32s[labels.ofs + j];

          if ((ctrl_depth > 0) && (ctrl_depth - ofs) > 0) {
            const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, ofs);
            if (!tail) {
              fail(env, "br_table: ctrl_stack_peek_tail failed");
              return false;
            }

            // get destination label
            const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

            // emit conditional jump
            | cmp eax, j
            | je =>label
          } else {
            // emit exit success
            | cmp eax, j
            | je ->exit_success
          }
        }

        // emit unconditional jump to default label
        {
          // get offset of last branch target
          const uint32_t ofs = mod->u32s[labels.ofs + labels.len - 1];

          if ((ctrl_depth > 0) && (ctrl_depth - ofs) > 0) {
            const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, ofs);
            if (!tail) {
              fail(env, "br_table: ctrl_stack_peek_tail failed");
              return false;
            }

            // get destination label
            const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

            // emit unconditional jump to default label
            | jmp =>label
          } else {
            // emit unconditional jump to exit_success
            | jmp ->exit_success
          }
        }
      }

      break;
    case PWASM_OP_RETURN:
      // emit unconditional jump to exit_success
      | jmp ->exit_success

      break;
    case PWASM_OP_CALL:
      // save stack position, push registers
      | stack_save_depth
      | save_regs

      // set parameters
      | mov r_arg0, r_env
      | mov r_arg1, mod_id
      | mov r_arg2, in.v_index

      // call func
      | mov64 rax, (uintptr_t) pwasm_env_call_func
      | call rax

      // restore frame
      | restore_regs

      // check for error
      | cmp eax, 0
      | je ->exit_failure

      // restore stack register
      | stack_reg_init

      break;
    case PWASM_OP_CALL_INDIRECT:
      {
        // TODO: get table ID from instruction
        const uint32_t table_id = pwasm_env_get_table_index(env, mod_id, 0);

        // get element offset, pop stack
        | mov r_arg4d, [r_stack - sizeof(pwasm_val_t)] // get element
        | stack_dec

        // save stack position, push registers
        | stack_save_depth
        | save_regs

        // set parameters
        | mov r_arg0, r_env       // environment
        | mov r_arg1, mod_id      // mod handle
        | mov r_arg2, table_id    // table handle
        | mov r_arg3, in.v_index  // type ID
        // r_arg4d stored above   // elem offset

        // call func
        | mov64 rax, (uintptr_t) pwasm_dynasm_jit_call_indirect
        | call rax

        // restore frame
        | restore_regs

        // check for error
        | cmp eax, 0
        | je ->exit_failure

        // restore stack register
        | stack_reg_init
      }

      break;
    case PWASM_OP_DROP:
      | stack_dec

      break;
    case PWASM_OP_SELECT:
      // pop value, compare to zero
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | cmp eax, 0

      // get left value (FIXME: use xmm?)
      | cmovnz rax, [r_stack - 3 * sizeof(pwasm_val_t)]
      | cmovnz rbx, [r_stack - 3 * sizeof(pwasm_val_t) + sizeof(uint64_t)]

      // get right value (FIXME: use xmm?)
      | cmovz rax, [r_stack - 2 * sizeof(pwasm_val_t)]
      | cmovz rbx, [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)]

      // store result
      | mov [r_stack - 3 * sizeof(pwasm_val_t)], rax
      | mov [r_stack - 3 * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx

      // decriment stack
      | stack_decn 2

      break;
    case PWASM_OP_LOCAL_GET:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_base - ofs * sizeof(pwasm_val_t)]
        | mov rbx, [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_stack], rax
        | mov [r_stack + sizeof(uint64_t)], rbx
        | stack_inc
      }

      break;
    case PWASM_OP_LOCAL_SET:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_base - ofs * sizeof(pwasm_val_t)], rax
        | mov [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
        | stack_dec
      }

      break;
    case PWASM_OP_LOCAL_TEE:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_base - ofs * sizeof(pwasm_val_t)], rax
        | mov [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
      }

      break;
    case PWASM_OP_GLOBAL_GET:
      {
        // get global index
        const uint32_t global_id = env->cbs->get_global_index(env, mod_id, in.v_index);

        // emit call
        | save_regs
        | mov r_arg0, r_env
        | mov r_arg1, global_id
        | mov r_arg2, r_stack
        | mov64 rax, (uintptr_t) pwasm_env_get_global
        | call rax
        | restore_regs

        // check for error
        | cmp eax, 0
        | je ->exit_failure

        // increment stack
        | stack_inc
      }

      break;
    case PWASM_OP_GLOBAL_SET:
      {
        // get global index
        const uint32_t global_id = env->cbs->get_global_index(env, mod_id, in.v_index);

        // emit call
        | save_regs
        | mov r_arg0, r_env
        | mov r_arg1, global_id
        | mov r_arg2, [r_stack - sizeof(pwasm_val_t)]
        | mov r_arg3, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov64 rax, (uintptr_t) pwasm_env_set_global
        | call rax
        | restore_regs

        // check for error
        | cmp eax, 0
        | je ->exit_failure

        // decriment stack
        | stack_dec
      }

      break;
    // TODO: load, store, mem.grow, mem.size, v128.load
    // (need call to work before i can implement these)
    case PWASM_OP_I32_CONST:
    case PWASM_OP_F32_CONST:
      | mov dword [r_stack], in.v_i32
      | stack_inc

      break;
    case PWASM_OP_I64_CONST:
    case PWASM_OP_F64_CONST:
      | mov dword [r_stack], (uint32_t) in.v_i64
      | mov dword [r_stack + sizeof(uint32_t)], (in.v_i64 >> 32)
      | stack_inc

      break;
    case PWASM_OP_I32_EQZ:
      | i32_testop_init
      | cmp eax, 0
      | i32_testop_fini

      break;
    case PWASM_OP_I32_EQ:
      | i32_relop_init
      | sete al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_NE:
      | i32_relop_init
      | setne al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LT_S:
      | i32_relop_init
      | setl al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LT_U:
      | i32_relop_init
      | setb al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GT_S:
      | i32_relop_init
      | setg al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GT_U:
      | i32_relop_init
      | seta al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LE_S:
      | i32_relop_init
      | setle al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LE_U:
      | i32_relop_init
      | setbe al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GE_S:
      | i32_relop_init
      | setge al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GE_U:
      | i32_relop_init
      | setae al
      | i32_relop_fini

      break;
    case PWASM_OP_I64_EQZ:
      | i64_testop_init
      | cmp rax, 0
      | i64_testop_fini

      break;
    case PWASM_OP_I64_EQ:
      | i64_relop_init
      | sete al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_NE:
      | i64_relop_init
      | setne al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LT_S:
      | i64_relop_init
      | setl al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LT_U:
      | i64_relop_init
      | setb al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GT_S:
      | i64_relop_init
      | setg al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GT_U:
      | i64_relop_init
      | seta al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LE_S:
      | i64_relop_init
      | setle al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LE_U:
      | i64_relop_init
      | setbe al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GE_S:
      | i64_relop_init
      | setge al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GE_U:
      | i64_relop_init
      | setae al
      | i64_relop_fini

      break;
    case PWASM_OP_F32_EQ:
      | f32_relop_init
      | cmpss xmm0, xmm1, 0
      | f32_relop_fini

      break;
    case PWASM_OP_F32_NE:
      | f32_relop_init
      | cmpss xmm0, xmm1, 4
      | f32_relop_fini

      break;
    case PWASM_OP_F32_LT:
      | f32_relop_init
      | cmpss xmm0, xmm1, 1
      | f32_relop_fini

      break;
    case PWASM_OP_F32_GT:
      | f32_relop_init
      | cmpss xmm0, xmm1, 6
      | f32_relop_fini

      break;
    case PWASM_OP_F32_LE:
      | f32_relop_init
      | cmpss xmm0, xmm1, 2
      | f32_relop_fini

      break;
    case PWASM_OP_F32_GE:
      | f32_relop_init
      | cmpss xmm0, xmm1, 5
      | f32_relop_fini

      break;
    case PWASM_OP_F64_EQ:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 0
      | f64_relop_fini

      break;
    case PWASM_OP_F64_NE:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 4
      | f64_relop_fini

      break;
    case PWASM_OP_F64_LT:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 1
      | f64_relop_fini

      break;
    case PWASM_OP_F64_GT:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 6
      | f64_relop_fini

      break;
    case PWASM_OP_F64_LE:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 2
      | f64_relop_fini

      break;
    case PWASM_OP_F64_GE:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 5
      | f64_relop_fini

      break;
    case PWASM_OP_I32_CLZ:
      // FIXME: use lzcnt instead of bsr?
      | i32_unop_init
      | bsr ebx, eax
      | mov eax, 31
      | sub eax, ebx
      | i32_unop_fini

      break;
    case PWASM_OP_I32_CTZ:
      // FIXME: use tzcnt instead of bsf?
      | i32_unop_init
      | bsf eax, eax
      | i32_unop_fini

      break;
    case PWASM_OP_I32_POPCNT:
      | i32_unop_init
      | popcnt eax, eax
      | i32_unop_fini

      break;
    case PWASM_OP_I32_ADD:
      | i32_binop_init
      | add eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SUB:
      | i32_binop_init
      | sub eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_MUL:
      | i32_binop_init
      | mul ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_DIV_S:
      | i32_binop_init
      | cdq           // sign-extend eax into edx
      | idiv ebx      // signed divide
      | i32_binop_fini

      break;
    case PWASM_OP_I32_DIV_U:
      | i32_binop_init
      | mov edx, 0    // zero-extend into edx
      | div ebx       // unsigned divide
      | i32_binop_fini

      break;
    case PWASM_OP_I32_REM_S:
      | i32_binop_init
      | cdq           // sign-extend eax into edx
      | idiv ebx      // signed divide
      | mov eax, edx  // save remainder
      | i32_binop_fini

      break;
    case PWASM_OP_I32_REM_U:
      | i32_binop_init
      | mov edx, 0    // zero edx
      | div ebx       // unsigned divide
      | mov eax, edx  // save remainder
      | i32_binop_fini

      break;
    case PWASM_OP_I32_AND:
      | i32_binop_init
      | and eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_OR:
      | i32_binop_init
      | or eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_XOR:
      | i32_binop_init
      | xor eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SHL:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | shl eax, cl   // shift left
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SHR_S:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | sar eax, cl   // shift right (arithmetic)
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SHR_U:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | shr eax, cl   // shift right (logical)
      | i32_binop_fini

      break;
    case PWASM_OP_I32_ROTL:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | rol eax, cl   // rotate left
      | i32_binop_fini

      break;
    case PWASM_OP_I32_ROTR:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | ror eax, cl   // rotate right
      | i32_binop_fini

      break;
    case PWASM_OP_I64_CLZ:
      // FIXME: use lzcnt instead of bsr?
      | i64_unop_init
      | bsr rbx, rax
      | mov eax, 63
      | sub eax, ebx
      | i64_unop_fini

      break;
    case PWASM_OP_I64_CTZ:
      // FIXME: use tzcnt instead of bsf?
      | i64_unop_init
      | bsf rax, rax
      | i64_unop_fini

      break;
    case PWASM_OP_I64_POPCNT:
      | i64_unop_init
      | popcnt rax, rax
      | i64_unop_fini

      break;
    case PWASM_OP_I64_ADD:
      | i64_binop_init
      | add rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SUB:
      | i64_binop_init
      | sub rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_MUL:
      | i64_binop_init
      | mul rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_DIV_S:
      | i64_binop_init
      | cqo           // sign-extend eax into edx
      | idiv rbx      // signed divide
      | i64_binop_fini

      break;
    case PWASM_OP_I64_DIV_U:
      | i64_binop_init
      | mov rdx, 0    // zero-extend into edx
      | div rbx       // unsigned divide
      | i64_binop_fini

      break;
    case PWASM_OP_I64_REM_S:
      | i64_binop_init
      | cqo           // sign-extend eax into edx
      | idiv rbx      // signed divide
      | mov rax, rdx  // save remainder
      | i64_binop_fini

      break;
    case PWASM_OP_I64_REM_U:
      | i64_binop_init
      | mov rdx, 0    // zero edx
      | div rbx       // unsigned divide
      | mov rax, rdx  // save remainder
      | i64_binop_fini

      break;
    case PWASM_OP_I64_AND:
      | i64_binop_init
      | and rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_OR:
      | i64_binop_init
      | or rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_XOR:
      | i64_binop_init
      | xor rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SHL:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | shl rax, cl   // shift left
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SHR_S:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | sar rax, cl   // shift right (arithmetic)
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SHR_U:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | shr rax, cl   // shift right (logical)
      | i64_binop_fini

      break;
    case PWASM_OP_I64_ROTL:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | rol rax, cl   // rotate left
      | i64_binop_fini

      break;
    case PWASM_OP_I64_ROTR:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | ror rax, cl   // rotate right
      | i64_binop_fini

      break;
    case PWASM_OP_F32_ABS:
      | f32_unop_init
      // FIXME: the next two lines should eventually be generated in the
      // prologue
      // ref: https://stackoverflow.com/questions/32408665/fastest-way-to-compute-absolute-value-using-sse
      | pcmpeqd  xmm5, xmm5 // fill xmm5 with 0xFF
      | psrld xmm5, 1 // logical shift right one bit (0x7F)
      | andps xmm0, xmm5 // mask sign bit
      | f32_unop_fini

      break;
    case PWASM_OP_F32_NEG:
      | f32_unop_init
      | xorps xmm6, xmm6 // xmm6 = 0
      | subss xmm6, xmm0 // xmm6 -= xmm0
      | movss xmm0, xmm6 // xmm0 = xmm6
      | f32_unop_fini

      break;
    case PWASM_OP_F32_CEIL:
      | f32_unop_init
      | roundps xmm0, xmm0, 2 // xmm0 = ceil(xmm0)
      | f32_unop_fini

      break;
    case PWASM_OP_F32_FLOOR:
      | f32_unop_init
      | roundps xmm0, xmm0, 1 // xmm0 = floor(xmm0)
      | f32_unop_fini

      break;
    case PWASM_OP_F32_TRUNC:
      | f32_unop_init
      | roundps xmm0, xmm0, 3 // xmm0 = trunc(xmm0)
      | f32_unop_fini

      break;
    case PWASM_OP_F32_NEAREST:
      | f32_unop_init
      | roundps  xmm0, xmm0, 0 // xmm0 = round(xmm0)
      | f32_unop_fini

      break;
    case PWASM_OP_F32_SQRT:
      | f32_unop_init
      | sqrtss xmm0, xmm0 // xmm0 = sqrt(xmm0)
      | f32_unop_fini

      break;
    case PWASM_OP_F32_ADD:
      | f32_binop_init
      | addss xmm0, xmm1 // xmm0 += xmm1
      | f32_binop_fini

      break;
    case PWASM_OP_F32_SUB:
      | f32_binop_init
      | subss xmm0, xmm1 // xmm0 -= xmm1
      | f32_binop_fini

      break;
    case PWASM_OP_F32_MUL:
      | f32_binop_init
      | mulss xmm0, xmm1 // xmm0 *= xmm1
      | f32_binop_fini

      break;
    case PWASM_OP_F32_DIV:
      | f32_binop_init
      | divss xmm0, xmm1 // xmm0 /= xmm1
      | f32_binop_fini

      break;
    case PWASM_OP_F32_MIN:
      | f32_binop_init
      | minss xmm0, xmm1 // xmm0 = min(xmm0, xmm1)
      | f32_binop_fini

      break;
    case PWASM_OP_F32_MAX:
      | f32_binop_init
      | maxss xmm0, xmm1 // xmm0 = max(xmm0, xmm1)
      | f32_binop_fini

      break;
    case PWASM_OP_F32_COPYSIGN:
      | f32_binop_init
      // FIXME: the next two lines should eventually be generated in the
      // prologue
      // ref: https://stackoverflow.com/questions/32408665/fastest-way-to-compute-absolute-value-using-sse
      | pcmpeqd  xmm5, xmm5 // xmm5 = 0xFFFFFFFF
      | psrld xmm5, 1       // xmm5 >>= 1 (0x7FFFFFFF)
      | andps xmm0, xmm5    // xmm0 &= xmm5 (exclude sign bit)
      | pcmpeqd xmm6, xmm6  // xmm5 = 0xFFFFFFFF
      | pslld xmm6, 31      // xmm6 <<= 31 (0x8000000)
      | andps xmm1, xmm6    // xmm1 &= xmm6 (only sign bit)
      | orps xmm0, xmm1     // xmm0 |= xmm1
      | f32_binop_fini

      break;
    case PWASM_OP_F64_ABS:
      | f64_unop_init
      // FIXME: the next two lines should eventually be generated in the
      // prologue
      // ref: https://stackoverflow.com/questions/32408665/fastest-way-to-compute-absolute-value-using-sse
      | pcmpeqd  xmm5, xmm5 // fill xmm5 with 0xFF
      | psrld xmm5, 1 // logical shift right one bit (0x7F)
      | andpd xmm0, xmm5 // mask sign bit
      | f64_unop_fini

      break;
    case PWASM_OP_F64_NEG:
      | f64_unop_init
      | xorpd xmm6, xmm6 // xmm6 = 0
      | subsd xmm6, xmm0 // xmm6 -= xmm0
      | movsd xmm0, xmm6 // xmm0 = xmm6
      | f64_unop_fini

      break;
    case PWASM_OP_F64_CEIL:
      | f64_unop_init
      | roundpd xmm0, xmm0, 2 // xmm0 = ceil(xmm0)
      | f64_unop_fini

      break;
    case PWASM_OP_F64_FLOOR:
      | f64_unop_init
      | roundpd xmm0, xmm0, 1 // xmm0 = floor(xmm0)
      | f64_unop_fini

      break;
    case PWASM_OP_F64_TRUNC:
      | f64_unop_init
      | roundpd xmm0, xmm0, 3 // xmm0 = trunc(xmm0)
      | f64_unop_fini

      break;
    case PWASM_OP_F64_NEAREST:
      | f64_unop_init
      | roundpd  xmm0, xmm0, 0 // xmm0 = round(xmm0)
      | f64_unop_fini

      break;
    case PWASM_OP_F64_SQRT:
      | f64_unop_init
      | sqrtsd xmm0, xmm0 // xmm0 = sqrt(xmm0)
      | f64_unop_fini

      break;
    case PWASM_OP_F64_ADD:
      | f64_binop_init
      | addsd xmm0, xmm1 // xmm0 += xmm1
      | f64_binop_fini

      break;
    case PWASM_OP_F64_SUB:
      | f64_binop_init
      | subsd xmm0, xmm1 // xmm0 -= xmm1
      | f64_binop_fini

      break;
    case PWASM_OP_F64_MUL:
      | f64_binop_init
      | mulsd xmm0, xmm1 // xmm0 *= xmm1
      | f64_binop_fini

      break;
    case PWASM_OP_F64_DIV:
      | f64_binop_init
      | divsd xmm0, xmm1 // xmm0 /= xmm1
      | f64_binop_fini

      break;
    case PWASM_OP_F64_MIN:
      | f64_binop_init
      | minsd xmm0, xmm1 // xmm0 = min(xmm0, xmm1)
      | f64_binop_fini

      break;
    case PWASM_OP_F64_MAX:
      | f64_binop_init
      | maxsd xmm0, xmm1 // xmm0 = max(xmm0, xmm1)
      | f64_binop_fini

      break;
    case PWASM_OP_F64_COPYSIGN:
      | f64_binop_init
      // FIXME: the next two lines should eventually be generated in the
      // prologue
      // ref: https://stackoverflow.com/questions/32408665/fastest-way-to-compute-absolute-value-using-sse
      | pcmpeqd  xmm5, xmm5 // xmm5 = 0xFFFFFFFF
      | psrld xmm5, 1       // xmm5 >>= 1 (0x7FFFFFFF)
      | andpd xmm0, xmm5    // xmm0 &= xmm5 (exclude sign bit)
      | pcmpeqd xmm6, xmm6  // xmm5 = 0xFFFFFFFF
      | pslld xmm6, 31      // xmm6 <<= 31 (0x8000000)
      | andpd xmm1, xmm6    // xmm1 &= xmm6 (only sign bit)
      | orpd xmm0, xmm1     // xmm0 |= xmm1
      | f64_binop_fini

      break;
    case PWASM_OP_I32_WRAP_I64:
      // do nothing
      break;
    case PWASM_OP_I32_TRUNC_F32_S:
      | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]
      | cvttss2si eax, xmm0
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32_TRUNC_SAT_F32_S:
      | pxor xmm1, xmm1
      | mov ebx, 0x80000000UL
      | mov ecx, 0x7FFFFFFFUL
      | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]
      | ucomiss xmm0, xmm1
      | cmova ebx, ecx
      | cvttss2si eax, xmm0
      | cmp eax, 0x80000000UL
      | cmovz eax, ebx
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32_TRUNC_F32_U:
    case PWASM_OP_I32_TRUNC_SAT_F32_U:
      // FIXME: requires avx512
      // | vcvttss2usi eax, xmm0

      {
        const size_t done = max_label;
        max_label += 1;
        dasm_growpc(&dasm, max_label);

        // xmm0 = stack[-1].f32
        | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]

        // xmm2 = 0x10000000
        | mov ebx, 0x10000
        | cvtsi2ss xmm2, ebx
        | mulss xmm2, xmm2

        | xor eax, eax
        | xorps xmm1, xmm1
        | ucomiss xmm1, xmm0
        | ja =>done

        | comiss xmm0, xmm2
        | mov eax, 0xFFFFFFFF
        | ja =>done
        | cvttss2si rax, xmm0

        // stack[-1].i32 = eax
        | =>done:
        | mov [r_stack - sizeof(pwasm_val_t)], eax
      }

      break;
    case PWASM_OP_I32_TRUNC_F64_S:
      | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | cvttsd2si eax, xmm0
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32_TRUNC_SAT_F64_S:
      | pxor xmm1, xmm1
      | mov ebx, 0x80000000UL
      | mov ecx, 0x7FFFFFFFUL
      | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | ucomisd xmm0, xmm1
      | cmova ebx, ecx
      | cvttsd2si eax, xmm0
      | cmp eax, 0x80000000UL
      | cmovz eax, ebx
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32_TRUNC_F64_U:
    case PWASM_OP_I32_TRUNC_SAT_F64_U:
      // FIXME: requires avx512
      // | cvttsd2usi eax, xmm0

      {
        const size_t done = max_label;
        max_label += 1;
        dasm_growpc(&dasm, max_label);

        // xmm0 = stack[-1].f64
        | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]

        // xmm2 = 0x10000000
        | mov ebx, 0x10000
        | cvtsi2sd xmm2, ebx
        | mulsd xmm2, xmm2

        | xor eax, eax
        | xorpd xmm1, xmm1
        | ucomisd xmm1, xmm0
        | ja =>done

        | comisd xmm0, xmm2
        | mov eax, 0xFFFFFFFF
        | ja =>done
        | cvttsd2si rax, xmm0

        // stack[-1].i32 = eax
        | =>done:
        | mov [r_stack - sizeof(pwasm_val_t)], eax
      }

      break;
    case PWASM_OP_I64_EXTEND_I32_S:
      | mov eax, dword [r_stack - sizeof(pwasm_val_t)]
      | cdqe          // rax = sign-extend(eax)
      | mov [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_I64_EXTEND_I32_U:
      | xor eax, eax
      | mov [r_stack - sizeof(pwasm_val_t) + sizeof(uint32_t)], eax

      break;
    case PWASM_OP_I64_TRUNC_F32_S:
      | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]
      | cvttss2si rax, xmm0
      | mov [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_I64_TRUNC_SAT_F32_S:
      {
        const size_t done = max_label;
        max_label += 1;
        dasm_growpc(&dasm, max_label);

        // xmm0 = stack[-1].f32
        | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]

        // rbx = 0x8000_0000_0000_0000
        | xor rbx, rbx
        | not rbx
        | shr rbx, 1
        | not rbx

        | cvttss2si rax, xmm0 // rax = cvtt(xmm0)
        | cmp rax, rbx        // rax == rbx?
        | jne =>done          // jmp done if (rax != rbx)

        | pxor xmm1, xmm1    // xmm1 = 0
        | ucomiss xmm1, xmm0   // cmp(xmm1, xmm0)
        | ja =>done           // jmp done if (xmm0 < 0)

        // rax = 0x7FFF_FFFF_FFFF_FFFF
        | xor rax, rax
        | not rax
        | shr rax, 1

        // stack[-1].i32 = rax
        | =>done:
        | mov [r_stack - sizeof(pwasm_val_t)], rax
      }

      break;
    case PWASM_OP_I64_TRUNC_F32_U:
    case PWASM_OP_I64_TRUNC_SAT_F32_U:
      {
        const size_t done = max_label;
        max_label++;
        dasm_growpc(&dasm, max_label);

        // FIXME: requires avx512
        // | vcvttss2si rax, xmm0

        // xmm0 = stack[-1].f32
        | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]

        // xmm2 = 0x10000000
        | mov ebx, 0x10000
        | cvtsi2ss xmm2, ebx
        | mulss xmm2, xmm2
        | mulss xmm2, xmm2

        | xor rax, rax
        | xorps xmm1, xmm1
        | ucomiss xmm1, xmm0
        | ja =>done

        | comiss xmm0, xmm2
        | mov rax, 0xFFFFFFFFFFFFFFFFULL
        | ja =>done
        | cvttss2si rax, xmm0

        // stack[-1].i32 = rax
        | =>done:
        | mov [r_stack - sizeof(pwasm_val_t)], rax
      }

      break;
    case PWASM_OP_I64_TRUNC_F64_S:
      | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | cvttsd2si rax, xmm0
      | mov [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_I64_TRUNC_SAT_F64_S:
      {
        const size_t done = max_label;
        max_label += 1;
        dasm_growpc(&dasm, max_label);

        // xmm0 = stack[-1].f32
        | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]

        // rbx = 0x8000_0000_0000_0000
        | xor rbx, rbx
        | not rbx
        | shr rbx, 1
        | not rbx

        | cvttsd2si rax, xmm0 // rax = cvtt(xmm0)
        | cmp rax, rbx        // rax == rbx?
        | jne =>done          // jmp done if (rax != rbx)

        | pxor xmm1, xmm1    // xmm1 = 0
        | ucomisd xmm1, xmm0   // cmp(xmm1, xmm0)
        | ja =>done           // jmp done if (xmm0 < 0)

        // rax = 0x7FFF_FFFF_FFFF_FFFF
        | xor rax, rax
        | not rax
        | shr rax, 1

        // stack[-1].i32 = rax
        | =>done:
        | mov [r_stack - sizeof(pwasm_val_t)], rax
      }

      break;
    case PWASM_OP_I64_TRUNC_F64_U:
    case PWASM_OP_I64_TRUNC_SAT_F64_U:
      {
        const size_t done = max_label;
        max_label++;
        dasm_growpc(&dasm, max_label);

        // FIXME: requires avx512
        // | vcvttsd2usi rax, xmm0

        // xmm0 = stack[-1].f64
        | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]

        // xmm2 = 0x1000000000000000
        | mov ebx, 0x10000
        | cvtsi2sd xmm2, ebx
        | mulsd xmm2, xmm2
        | mulsd xmm2, xmm2

        | xor rax, rax
        | xorpd xmm1, xmm1
        | ucomisd xmm1, xmm0
        | ja =>done

        | comisd xmm0, xmm2
        | mov rax, 0xFFFFFFFFFFFFFFFFULL
        | ja =>done
        | cvttsd2si rax, xmm0

        // stack[-1].i32 = rax
        | =>done:
        | mov [r_stack - sizeof(pwasm_val_t)], rax
      }

      break;
    case PWASM_OP_F32_CONVERT_I32_S:
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | cvtsi2ss xmm0, eax // xmm0 = (float) rax
      | movss dword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_F32_CONVERT_I32_U:
      {
        const size_t no_shift = max_label,
                     done = max_label + 1;
        max_label += 2;
        dasm_growpc(&dasm, max_label);

        | xor rax, rax
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, rax
        | and rbx, 0x80000000
        | jz =>no_shift

        | shr eax, 1          // rax /= 2
        | cvtsi2ss xmm0, eax  // xmm0 = (float) eax
        | mov eax, 2          // eax = 2
        | cvtsi2ss xmm1, eax  // xmm1 = (float) eax (xmm1 = 2.0)
        | mulss xmm0, xmm1    // xmm0 *= xmm1 (xmm0 *= 2.0)
        | jmp =>done

        | =>no_shift:
        | cvtsi2ss xmm0, eax  // xmm0 = (float) eax

        | =>done:
        | movss dword [r_stack - sizeof(pwasm_val_t)], xmm0
      }

      break;
    case PWASM_OP_F32_CONVERT_I64_S:
      | mov rax, [r_stack - sizeof(pwasm_val_t)]
      | cvtsi2ss xmm0, rax // xmm0 = (double) rax
      | movss dword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_F32_CONVERT_I64_U:
      {
        const size_t no_shift = max_label,
                     done = max_label + 1;
        max_label += 2;
        dasm_growpc(&dasm, max_label);

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, 0x8000000000000000ULL
        | and rbx, rax
        | jz =>no_shift

        | shr rax, 1          // rax /= 2
        | cvtsi2ss xmm0, rax  // xmm0 = (float) rax
        | mov rax, 2          // eax = 2
        | cvtsi2ss xmm1, rax  // xmm1 = (float) rax (xmm1 = 2.0)
        | mulss xmm0, xmm1    // xmm0 *= xmm1 (xmm0 *= 2.0)
        | jmp =>done

        | =>no_shift:
        | cvtsi2ss xmm0, rax  // xmm0 = (float) rax

        | =>done:
        | movss dword [r_stack - sizeof(pwasm_val_t)], xmm0
      }

      break;
    case PWASM_OP_F32_DEMOTE_F64:
      | movsd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | cvtsd2ss xmm0, xmm0 // xmm0 = (float) xmm0
      | movss dword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_F64_CONVERT_I32_S:
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | cvtsi2sd xmm0, eax // xmm0 = (double) eax
      | movsd qword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_F64_CONVERT_I32_U:
      | xor rax, rax
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | cvtsi2sd xmm0, rax // xmm0 = (double) rax
      | movsd qword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_F64_CONVERT_I64_S:
      | mov rax, [r_stack - sizeof(pwasm_val_t)]
      | cvtsi2sd xmm0, rax // xmm0 = (double) rax
      | movsd qword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_F64_CONVERT_I64_U:
      {
        const size_t no_shift = max_label,
                     done = max_label + 1;
        max_label += 2;
        dasm_growpc(&dasm, max_label);

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, 0x8000000000000000ULL
        | and rbx, rax
        | jz =>no_shift

        | shr rax, 1          // rax /= 2
        | cvtsi2sd xmm0, rax  // xmm0 = (double) rax
        | mov rax, 2          // eax = 2
        | cvtsi2sd xmm1, rax  // xmm1 = (double) rax (xmm1 = 2.0)
        | mulsd xmm0, xmm1    // xmm0 *= xmm1 (xmm0 *= 2.0)
        | jmp =>done

        | =>no_shift:
        | cvtsi2sd xmm0, rax  // xmm0 = (double) rax

        | =>done:
        | movsd qword [r_stack - sizeof(pwasm_val_t)], xmm0
      }

      break;
    case PWASM_OP_F64_PROMOTE_F32:
      | movss xmm0, dword [r_stack - sizeof(pwasm_val_t)]
      | cvtss2sd xmm0, xmm0
      | movsd qword [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_I32_REINTERPRET_F32:
    case PWASM_OP_I64_REINTERPRET_F64:
    case PWASM_OP_F32_REINTERPRET_I32:
    case PWASM_OP_F64_REINTERPRET_I64:
      // do nothing
      break;
    case PWASM_OP_I32_EXTEND8_S:
      | movsx eax, byte [r_stack - sizeof(pwasm_val_t)]
      | mov dword [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32_EXTEND16_S:
      | movsx eax, word [r_stack - sizeof(pwasm_val_t)]
      | mov dword [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I64_EXTEND8_S:
      | movsx rax, byte [r_stack - sizeof(pwasm_val_t)]
      | mov qword [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_I64_EXTEND16_S:
      | movsx rax, word [r_stack - sizeof(pwasm_val_t)]
      | mov qword [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_I64_EXTEND32_S:
      | movsxd rax, dword [r_stack - sizeof(pwasm_val_t)]
      | mov qword [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_V128_CONST:
      | mov eax, in.v_v128.i32[0]
      | mov ebx, in.v_v128.i32[1]
      | mov ecx, in.v_v128.i32[2]
      | mov edx, in.v_v128.i32[3]

      | mov dword [r_stack + 0 * sizeof(uint32_t)], eax
      | mov dword [r_stack + 1 * sizeof(uint32_t)], ebx
      | mov dword [r_stack + 2 * sizeof(uint32_t)], ecx
      | mov dword [r_stack + 3 * sizeof(uint32_t)], edx

      | stack_inc
      // note: the following movd's are actually "movq", but dynasm does
      // not understand "movq xmm, r64", see the comments here:
      // https://stackoverflow.com/questions/6654099/how-to-move-128-bit-immediates-to-xmm-registers
      // | movd xmm0, rax
      // | movd xmm1, rbx
      // | unpcklpd xmm0, xmm1
      // | movups [r_stack], xmm0

      break;
    case PWASM_OP_V8X16_SHUFFLE:
      // FIXME: this could be faster
      for (size_t j = 0; j < 16; j++) {
        const uint8_t ofs = in.v_v128.i8[j] & 0x1F;
        const uint8_t dst = ((ofs < 16) ? 2 : 1) * sizeof(pwasm_val_t);
        | mov al, byte [r_stack - dst + (ofs & 0xF)]
        | mov byte [r_stack + j], al
      }

      | mov rax, qword [r_stack]
      | mov rbx, qword [r_stack + 8]
      | mov qword [r_stack - 2 * sizeof(pwasm_val_t)], rax
      | mov qword [r_stack - 2 * sizeof(pwasm_val_t) + 8], rbx
      | stack_dec

      break;
    case PWASM_OP_V8X16_SWIZZLE:
      | v128_binop_init
      | pshufb xmm0, xmm1
      | v128_binop_fini
      break;
    case PWASM_OP_I8X16_SPLAT:
      // vbroadcast is avx512-only

      | xor rax, rax    // zero rax
      | mov al, byte [r_stack - sizeof(pwasm_val_t)]

      | mov ah, al      // ah = al (splat)
      | mov rbx, rax    // rbx = rax
      | shl ebx, 16     // ebx <<= 16
      | or eax, ebx     // eax |= ebx
      | shl rbx, 16     // rbx <<= 16
      | or rax, rbx     // rax |= rbx
      | shl rbx, 16     // rbx <<= 16
      | or rax, rbx     // rax |= rbx

      | mov qword [r_stack - sizeof(pwasm_val_t)], rax
      | mov qword [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)], rax

      break;
    case PWASM_OP_I16X8_SPLAT:
      // vbroadcast is avx512-only
      | xor rax, rax    // zero rax
      | mov ax, word [r_stack - sizeof(pwasm_val_t)]

      | mov rbx, rax    // rbx = rax
      | shl ebx, 16     // ebx <<= 16
      | or eax, ebx     // eax |= ebx
      | shl rbx, 16     // ebx <<= 16
      | or rax, rbx     // rax |= rbx
      | shl rbx, 16     // rbx <<= 16
      | or rax, rbx     // rax |= rbx

      | mov qword [r_stack - sizeof(pwasm_val_t)], rax
      | mov qword [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)], rax

      break;
    case PWASM_OP_I32X4_SPLAT:
    case PWASM_OP_F32X4_SPLAT:
      // vbroadcast is avx512-only
      | mov eax, dword [r_stack - sizeof(pwasm_val_t)]

      | mov dword [r_stack - sizeof(pwasm_val_t) + 0 * sizeof(uint32_t)], eax
      | mov dword [r_stack - sizeof(pwasm_val_t) + 1 * sizeof(uint32_t)], eax
      | mov dword [r_stack - sizeof(pwasm_val_t) + 2 * sizeof(uint32_t)], eax
      | mov dword [r_stack - sizeof(pwasm_val_t) + 3 * sizeof(uint32_t)], eax

      break;
    case PWASM_OP_I64X2_SPLAT:
    case PWASM_OP_F64X2_SPLAT:
      // vbroadcast is avx512-only
      | mov rax, qword [r_stack - sizeof(pwasm_val_t)]
      | mov qword [r_stack - sizeof(pwasm_val_t) + 8], rax

      break;
    case PWASM_OP_I8X16_EXTRACT_LANE_S:
      // pextrb, movsx/cbd
      | movsx eax, byte [r_stack - sizeof(pwasm_val_t) + in.v_index]
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I8X16_EXTRACT_LANE_U:
      // pextrb, movzx/cbd
      | movzx eax, byte [r_stack - sizeof(pwasm_val_t) + in.v_index]
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I8X16_REPLACE_LANE:
      | mov al, byte [r_stack - sizeof(pwasm_val_t)]
      | mov byte [r_stack - 2 * sizeof(pwasm_val_t) + in.v_index], al
      | stack_dec

      break;
    case PWASM_OP_I16X8_EXTRACT_LANE_S:
      // pextrw, movsx/cwd
      | movsx eax, word [r_stack - sizeof(pwasm_val_t) + in.v_index * 2]
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I16X8_EXTRACT_LANE_U:
      // pextrw, movzx/cwd
      | xor eax, eax
      | mov ax, word [r_stack - sizeof(pwasm_val_t) + in.v_index * 2]
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I16X8_REPLACE_LANE:
      | mov ax, word [r_stack - sizeof(pwasm_val_t)]
      | mov word [r_stack - 2 * sizeof(pwasm_val_t) + in.v_index * 2], ax
      | stack_dec

      break;
    case PWASM_OP_I32X4_EXTRACT_LANE:
    case PWASM_OP_F32X4_EXTRACT_LANE:
      // pextrd
      | mov eax, dword [r_stack - sizeof(pwasm_val_t) + in.v_index * 4]
      | mov dword [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32X4_REPLACE_LANE:
    case PWASM_OP_F32X4_REPLACE_LANE:
      | mov eax, dword [r_stack - sizeof(pwasm_val_t)]
      | mov [r_stack - 2 * sizeof(pwasm_val_t) + in.v_index * 4], eax
      | stack_dec

      break;
    case PWASM_OP_I64X2_EXTRACT_LANE:
    case PWASM_OP_F64X2_EXTRACT_LANE:
      // pextrq
      | mov rax, qword [r_stack - sizeof(pwasm_val_t) + in.v_index * 8]
      | mov qword [r_stack - sizeof(pwasm_val_t)], rax

      break;
    case PWASM_OP_I64X2_REPLACE_LANE:
    case PWASM_OP_F64X2_REPLACE_LANE:
      | mov rax, qword [r_stack - sizeof(pwasm_val_t)]
      | mov [r_stack - 2 * sizeof(pwasm_val_t) + in.v_index * 8], rax
      | stack_dec

      break;
    case PWASM_OP_I8X16_EQ:
      | v128_binop_init
      | pcmpeqb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_NE:
      | v128_binop_init

      | pcmpeqb xmm2, xmm2  // xmm2 = 0xFF...
      | pcmpeqb xmm0, xmm1  // xmm0 = (xmm0 == xmm1)
      | pxor xmm0, xmm2     // xmm0 ^= xmm2

      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_LT_S:
      | v128_inv_binop_init
      | pcmpgtb xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_LT_U:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxub xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqb xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | pcmpeqb xmm2, xmm2    // xmm2 = 0xFF...
      | pxor xmm0, xmm2       // xmm0 = ~xmm0
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_GT_S:
      | v128_binop_init
      | pcmpgtb xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_GT_U:
      // calculate inverse of le_u
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | pcmpeqb xmm3, xmm3    // xmm3 = 0xFF...
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminub xmm0, xmm1     // xmm0 = minu(xmm0, xmm1)
      | pcmpeqb xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | pxor xmm0, xmm3       // xmm0 ^= xmm3
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_LE_S:
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminsb xmm0, xmm1     // xmm0 = mins(xmm0, xmm1)
      | pcmpeqb xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_LE_U:
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminub xmm0, xmm1     // xmm0 = minu(xmm0, xmm1)
      | pcmpeqb xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_GE_S:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxsb xmm0, xmm1     // xmm0 = maxs(xmm0, xmm1)
      | pcmpeqb xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_GE_U:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxub xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqb xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_EQ:
      | v128_binop_init
      | pcmpeqw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_NE:
      | v128_binop_init

      | pcmpeqd xmm2, xmm2  // xmm2 = 0xFF...
      | pcmpeqw xmm0, xmm1  // xmm0 = (xmm0 == xmm1)
      | pxor xmm0, xmm2     // xmm0 ^= xmm2

      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_LT_S:
      | v128_inv_binop_init
      | pcmpgtw xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_LT_U:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxuw xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqw xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | pcmpeqw, xmm2, xmm2   // xmm2 = 0xff...
      | pxor xmm0, xmm2       // xmm0 = ~xmm2
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_GT_S:
      | v128_binop_init
      | pcmpgtw xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_GT_U:
      // calculate inverse of le_u
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | pcmpeqd xmm3, xmm3    // xmm3 = 0xFF...
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminuw xmm0, xmm1     // xmm0 = minu(xmm0, xmm1)
      | pcmpeqw xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | pxor xmm0, xmm3       // xmm0 ^= xmm3
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_LE_S:
      | v128_binop_init
      | pcmpeqw xmm2, xmm2  // xmm2 = 0xFF...
      | pcmpgtw xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | pxor xmm0, xmm2     // xmm0 = ~xmm0
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_LE_U:
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminuw xmm0, xmm1     // xmm0 = minu(xmm0, xmm1)
      | pcmpeqw xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_GE_S:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxsw xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqw xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_GE_U:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxuw xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqw xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_EQ:
      | v128_binop_init
      | pcmpeqd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_NE:
      | v128_binop_init

      | pcmpeqd xmm2, xmm2  // xmm2 = 0xFF...
      | pcmpeqd xmm0, xmm1  // xmm0 = (xmm0 == xmm1)
      | pxor xmm0, xmm2     // xmm0 ^= xmm2

      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_LT_S:
      | v128_inv_binop_init
      | pcmpgtd xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_LT_U:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxud xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqd xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | pcmpeqd xmm2, xmm2    // xmm2 = 0xff...
      | pxor xmm0, xmm2       // xmm0 = ~xmm0
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_GT_S:
      | v128_binop_init
      | pcmpgtd xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_GT_U:
      // calculate inverse of le_u
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | pcmpeqd xmm3, xmm3    // xmm3 = 0xFF...
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminud xmm0, xmm1     // xmm0 = minu(xmm0, xmm1)
      | pcmpeqd xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | pxor xmm0, xmm3       // xmm0 ^= xmm3
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_LE_S:
      | v128_binop_init
      | pcmpgtd xmm0, xmm1  // xmm1 = (xmm1 > xmm0)
      | pcmpeqd xmm2, xmm2  // xmm2 = 0xFF...
      | pxor xmm0, xmm2     // xmm0 = ~xmm0
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_LE_U:
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pminud xmm0, xmm1     // xmm0 = minu(xmm0, xmm1)
      | pcmpeqd xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_GE_S:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movaps xmm2, xmm0     // xmm2 = xmm1
      | pmaxsd xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqd xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_GE_U:
      // ref: https://stackoverflow.com/questions/16204663/sse-compare-packed-unsigned-bytes
      | v128_binop_init
      | movapd xmm2, xmm0     // xmm2 = xmm1
      | pmaxud xmm0, xmm1     // xmm0 = maxu(xmm0, xmm1)
      | pcmpeqd xmm0, xmm2    // xmm0 = (xmm0 == xmm2)
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_EQ:
      | v128_binop_init
      | cmpps xmm0, xmm1, 0   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_NE:
      | v128_binop_init
      | cmpps xmm0, xmm1, 4   // xmm0 = (xmm0 != xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_LT:
      | v128_binop_init
      | cmpps xmm0, xmm1, 1   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_GT:
      | v128_binop_init
      | cmpps xmm0, xmm1, 6   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_LE:
      | v128_binop_init
      | cmpps xmm0, xmm1, 2   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_GE:
      | v128_binop_init
      | cmpps xmm0, xmm1, 5   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_EQ:
      | v128_binop_init
      | cmppd xmm0, xmm1, 0   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_NE:
      | v128_binop_init
      | cmppd xmm0, xmm1, 4   // xmm0 = (xmm0 != xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_LT:
      | v128_binop_init
      | cmppd xmm0, xmm1, 1   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_GT:
      | v128_binop_init
      | cmppd xmm0, xmm1, 6   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_LE:
      | v128_binop_init
      | cmppd xmm0, xmm1, 2   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_GE:
      | v128_binop_init
      | cmppd xmm0, xmm1, 5   // xmm0 = (xmm0 == xmm1)
      | v128_binop_fini

      break;
    case PWASM_OP_V128_NOT:
      | v128_unop_init
      | pcmpeqd xmm1, xmm1    // xmm1 = 0xFF..
      | pxor xmm0, xmm1       // xmm0 = ~xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_V128_AND:
      | v128_binop_init
      | pand xmm0, xmm1       // xmm0 &= xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_V128_ANDNOT:
      | v128_inv_binop_init
      | pandn xmm0, xmm1      // xmm0 &= ~xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_V128_OR:
      | v128_binop_init
      | por xmm0, xmm1        // xmm0 |= xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_V128_XOR:
      | v128_binop_init
      | pxor xmm0, xmm1       // xmm0 ^= xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_V128_BITSELECT:
      // FIXME: i think there's an instruction for this

      | movupd xmm0, [r_stack - 3 * sizeof(pwasm_val_t)] // a
      | movupd xmm1, [r_stack - 2 * sizeof(pwasm_val_t)] // b
      | movupd xmm2, [r_stack - 1 * sizeof(pwasm_val_t)] // mask

      | pcmpeqd xmm3, xmm3    // xmm3 = 0xFF..
      | pand xmm0, xmm2       // a &= mask
      | pandn xmm2, xmm1      // xmm2 = (b & ~mask)
      | por xmm0, xmm2        // a = a | b

      | movupd [r_stack - 3 * sizeof(pwasm_val_t)], xmm0
      | stack_decn 2

      break;
    case PWASM_OP_I8X16_ABS:
      | v128_unop_init
      | pabsb xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I8X16_NEG:
      | v128_unop_init
      | pcmpeqd xmm1, xmm1    // xmm1 = 0xFF...
      | psignb xmm0, xmm1     // xmm0 = -xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I8X16_ANY_TRUE:
    case PWASM_OP_I16X8_ANY_TRUE:
    case PWASM_OP_I32X4_ANY_TRUE:
      | v128_unop_init
      | xor eax, eax
      | ptest xmm0, xmm0
      | setnz al
      | i32_unop_fini

      break;
    case PWASM_OP_I8X16_ALL_TRUE:
      | xor rax, rax
      | xor rbx, rbx

      for (size_t j = 0; j < 16; j++) {
        | cmp byte [r_stack - sizeof(pwasm_val_t) + j], 0
        | setz bl
        | or al, bl
      }

      | cmp al, 0
      | setnz al
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I8X16_NARROW_I16X8_S:
      | v128_binop_init
      | packsswb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_NARROW_I16X8_U:
      | v128_binop_init
      | packuswb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_SHL:
      // FIXME: there has to be a less idiotic way to do this
      | mov cl, byte [r_stack - 1 * sizeof(pwasm_val_t)]

      for (size_t j = 0; j < 16; j++) {
        | mov al, byte [r_stack - 2 * sizeof(pwasm_val_t) + j]
        | shl al, cl
        | mov byte [r_stack - 2 * sizeof(pwasm_val_t) + j], al
      }

      | stack_dec

      break;
    case PWASM_OP_I8X16_SHR_S:
      | mov cl, byte [r_stack - 1 * sizeof(pwasm_val_t)]

      for (size_t j = 0; j < 16; j++) {
        | mov al, byte [r_stack - 2 * sizeof(pwasm_val_t) + j]
        | sar al, cl
        | mov byte [r_stack - 2 * sizeof(pwasm_val_t) + j], al
      }

      | stack_dec

      break;
    case PWASM_OP_I8X16_SHR_U:
      | mov cl, byte [r_stack - 1 * sizeof(pwasm_val_t)]

      for (size_t j = 0; j < 16; j++) {
        | mov al, byte [r_stack - 2 * sizeof(pwasm_val_t) + j]
        | shr al, cl
        | mov byte [r_stack - 2 * sizeof(pwasm_val_t) + j], al
      }

      | stack_dec

      break;
    case PWASM_OP_I8X16_ADD:
      | v128_binop_init
      | paddb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_ADD_SATURATE_S:
      | v128_binop_init
      | paddsb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_ADD_SATURATE_U:
      | v128_binop_init
      | paddusb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_SUB:
      | v128_binop_init
      | psubb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_SUB_SATURATE_S:
      | v128_binop_init
      | psubsb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_SUB_SATURATE_U:
      | v128_binop_init
      | psubusb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_MIN_S:
      | v128_binop_init
      | pminsb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_MIN_U:
      | v128_binop_init
      | pminub xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_MAX_S:
      | v128_binop_init
      | pmaxsb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_MAX_U:
      | v128_binop_init
      | pmaxub xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I8X16_AVGR_U:
      | v128_binop_init
      | pavgb xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_ABS:
      | v128_unop_init
      | pabsw xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I16X8_NEG:
      | v128_unop_init
      | pcmpeqd xmm1, xmm1    // xmm1 = 0xFF...
      | psignw xmm0, xmm1     // xmm0 = -xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I16X8_ALL_TRUE:
      | xor rax, rax
      | xor rbx, rbx

      for (size_t j = 0; j < 8; j++) {
        | cmp word [r_stack - sizeof(pwasm_val_t) + j * sizeof(uint16_t)], 0
        | setz bl
        | or al, bl
      }

      | cmp al, 0
      | setnz al
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I16X8_NARROW_I32X4_S:
      | v128_binop_init
      | packssdw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_NARROW_I32X4_U:
      | v128_binop_init
      | packusdw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_WIDEN_LOW_I8X16_S:
      | v128_unop_init
      | pmovsxbw xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I16X8_WIDEN_LOW_I8X16_U:
      | v128_unop_init
      | pmovzxbw xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I16X8_WIDEN_HIGH_I8X16_S:
      | movdqu xmm0, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | pmovsxbw xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I16X8_WIDEN_HIGH_I8X16_U:
      | movdqu xmm0, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | pmovzxbw xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I16X8_SHL:
      | v128_r32_binop_init
      | psllw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_SHR_S:
      | v128_r32_binop_init
      | psraw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_SHR_U:
      | v128_r32_binop_init
      | psrlw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_ADD:
      | v128_binop_init
      | paddw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_ADD_SATURATE_S:
      | v128_binop_init
      | paddsw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_ADD_SATURATE_U:
      | v128_binop_init
      | paddusw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_SUB:
      | v128_binop_init
      | psubw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_SUB_SATURATE_S:
      | v128_binop_init
      | psubsw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_SUB_SATURATE_U:
      | v128_binop_init
      | psubusw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_MUL:
      | v128_binop_init
      | pmullw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_MIN_S:
      | v128_binop_init
      | pminsw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_MIN_U:
      | v128_binop_init
      | pminuw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_MAX_S:
      | v128_binop_init
      | pmaxsw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_MAX_U:
      | v128_binop_init
      | pmaxuw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I16X8_AVGR_U:
      | v128_binop_init
      | pavgw xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_ABS:
      | v128_unop_init
      | pabsd xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I32X4_NEG:
      | v128_unop_init
      | pcmpeqd xmm1, xmm1    // xmm1 = 0xFF...
      | psignd xmm0, xmm1     // xmm0 = -xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I32X4_ALL_TRUE:
      | xor rax, rax
      | xor rbx, rbx

      for (size_t j = 0; j < 4; j++) {
        | cmp dword [r_stack - sizeof(pwasm_val_t) + j * sizeof(uint32_t)], 0
        | setz bl
        | or al, bl
      }

      | cmp al, 0
      | setnz al
      | mov [r_stack - sizeof(pwasm_val_t)], eax

      break;
    case PWASM_OP_I32X4_WIDEN_LOW_I16X8_S:
      | v128_unop_init
      | pmovsxwd xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I32X4_WIDEN_LOW_I16X8_U:
      | v128_unop_init
      | pmovzxwd xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I32X4_WIDEN_HIGH_I16X8_S:
      | movdqu xmm0, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | pmovsxwd xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I32X4_WIDEN_HIGH_I16X8_U:
      | movdqu xmm0, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | pmovzxwd xmm0, xmm0
      | v128_unop_fini

      break;
    case PWASM_OP_I32X4_SHL:
      | v128_r32_binop_init
      | pslld xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_SHR_S:
      | v128_r32_binop_init
      | psrad xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_SHR_U:
      | v128_r32_binop_init
      | psrld xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_ADD:
      | v128_binop_init
      | paddd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_SUB:
      | v128_binop_init
      | psubd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_MUL:
      | v128_binop_init
      | pmulld xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_MIN_S:
      | v128_binop_init
      | pminsd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_MIN_U:
      | v128_binop_init
      | pminud xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_MAX_S:
      | v128_binop_init
      | pmaxsd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_MAX_U:
      | v128_binop_init
      | pmaxud xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I64X2_NEG:
      | v128_unop_init
      | pxor xmm1, xmm1       // xmm1 = 0
      | psubq xmm1, xmm0      // xmm1 -= xmm0
      | movdqu xmm0, xmm1     // xmm0 = xmm1
      | v128_unop_fini

      break;
    case PWASM_OP_I64X2_SHL:
      | v128_r32_binop_init
      | psllq xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I64X2_SHR_S:
      // FIXME: | psraq xmm0, xmm1
      | mov rax, qword [r_stack - 2 * sizeof(pwasm_val_t)]
      | mov rbx, qword [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | mov cl, byte [r_stack - 1 * sizeof(pwasm_val_t)]

      | sar rax, cl
      | sar rbx, cl

      | mov qword [r_stack - 2 * sizeof(pwasm_val_t)], rax
      | mov qword [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx

      | stack_dec

      break;
    case PWASM_OP_I64X2_SHR_U:
      | v128_r32_binop_init
      | psrlq xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I64X2_ADD:
      | v128_binop_init
      | paddq xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I64X2_SUB:
      | v128_binop_init
      | psubq xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I64X2_MUL:
      | mov rax, [r_stack - 2 * sizeof(pwasm_val_t)]
      | imul rax, [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | mov rbx, [r_stack - sizeof(pwasm_val_t)]
      | imul rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
      | mov [r_stack - 2 * sizeof(pwasm_val_t)], rax
      | mov [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
      | stack_dec

      break;
    case PWASM_OP_F32X4_ABS:
      | v128_unop_init
      | pxor xmm1, xmm1       // xmm1 = 0
      | subps xmm1, xmm0      // xmm1 = -xmm0
      | maxps xmm0, xmm1      // xmm0 = max(xmm0, xmm1)
      | v128_unop_fini

      break;
    case PWASM_OP_F32X4_NEG:
      | v128_unop_init
      | pxor xmm1, xmm1       // xmm1 = 0
      | subps xmm1, xmm0      // xmm1 -= xmm0
      | movaps xmm0, xmm1     // xmm0 = xmm1
      | v128_unop_fini

      break;
    case PWASM_OP_F32X4_SQRT:
      | v128_unop_init
      | sqrtps xmm0, xmm0     // xmm1 = sqrt(xmm0)
      | v128_unop_fini

      break;
    case PWASM_OP_F32X4_ADD:
      | v128_binop_init
      | addps xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_SUB:
      | v128_binop_init
      | subps xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_MUL:
      | v128_binop_init
      | mulps xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_DIV:
      | v128_binop_init
      | divps xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_MIN:
      | v128_binop_init
      | minps xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F32X4_MAX:
      | v128_binop_init
      | maxps xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_ABS:
      | v128_unop_init
      | pxor xmm1, xmm1       // xmm1 = 0
      | subpd xmm1, xmm0      // xmm1 = -xmm0
      | maxpd xmm0, xmm1      // xmm0 = max(xmm0, xmm1)
      | v128_unop_fini

      break;
    case PWASM_OP_F64X2_NEG:
      | v128_unop_init
      | pxor xmm1, xmm1       // xmm1 = 0
      | subpd xmm1, xmm0      // xmm1 -= xmm0
      | movapd xmm0, xmm1     // xmm0 = xmm1
      | v128_unop_fini

      break;
    case PWASM_OP_F64X2_SQRT:
      | v128_unop_init
      | sqrtpd xmm0, xmm0     // xmm1 = sqrt(xmm0)
      | v128_unop_fini

      break;
    case PWASM_OP_F64X2_ADD:
      | v128_binop_init
      | addpd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_SUB:
      | v128_binop_init
      | subpd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_MUL:
      | v128_binop_init
      | mulpd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_DIV:
      | v128_binop_init
      | divpd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_MIN:
      | v128_binop_init
      | minpd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_F64X2_MAX:
      | v128_binop_init
      | maxpd xmm0, xmm1
      | v128_binop_fini

      break;
    case PWASM_OP_I32X4_TRUNC_SAT_F32X4_S:
      // FIXME: | cvttps2pi xmm0, xmm0 (add to dynasm?)

      | pxor xmm1, xmm1 // xmm1 = 0
      for (size_t j = 0; j < 4; j++) {
        | mov ebx, 0x80000000UL
        | mov ecx, 0x7FFFFFFFUL
        | movss xmm0, dword [r_stack - sizeof(pwasm_val_t) + j * 4]
        | ucomiss xmm0, xmm1
        | cmova ebx, ecx
        | cvttss2si eax, xmm0
        | cmp eax, 0x80000000UL
        | cmovz eax, ebx
        | mov [r_stack - sizeof(pwasm_val_t) + j * 4], eax
      }

      break;
    case PWASM_OP_I32X4_TRUNC_SAT_F32X4_U:
      // FIXME: want vcvtps2udq, but that's AVX512

      {
        const size_t label = max_label;
        max_label += 4;
        dasm_growpc(&dasm, max_label);

        // xmm1 = 0
        | xorps xmm1, xmm1

        // xmm2 = 0x10000000
        | mov ebx, 0x10000
        | cvtsi2ss xmm2, ebx
        | mulss xmm2, xmm2

        for (size_t j = 0; j < 4; j++) {
          const size_t done = label + j;

          // xmm0 = r_stack[-1].v128.f32[j]
          | movss xmm0, dword [r_stack - sizeof(pwasm_val_t) + j * 4]

          // clamp to min(u32)
          | xor eax, eax
          | ucomiss xmm1, xmm0
          | ja =>done

          // clamp to max(u32)
          | mov eax, 0xFFFFFFFF
          | ucomiss xmm0, xmm2
          | ja =>done
          | cvttss2si eax, xmm0

          // stack[-1].v128.i32[j] = eax
          | =>done:
          | mov dword [r_stack - sizeof(pwasm_val_t) + j * 4], eax
        }
      }

      break;
    case PWASM_OP_F32X4_CONVERT_I32X4_S:
      | cvtpi2ps xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | v128_unop_fini

      break;
    case PWASM_OP_F32X4_CONVERT_I32X4_U:
      // FIXME: want vcvtps2udq (avx512)
      {
        const size_t label = max_label;
        max_label += 8;
        dasm_growpc(&dasm, max_label);

        for (size_t j = 0; j < 4; j++) {
          const size_t no_shift = label + 2 * j,
                       done = label + 2 * j + 1;

          | xor rax, rax
          | mov eax, [r_stack - sizeof(pwasm_val_t) + j * 4]
          | mov rbx, rax
          | and rbx, 0x80000000
          | jz =>no_shift // jz no_shift

          | shr eax, 1          // rax /= 2
          | cvtsi2ss xmm0, eax  // xmm0 = (float) eax
          | mov eax, 2          // eax = 2
          | cvtsi2ss xmm1, eax  // xmm1 = (float) eax (xmm1 = 2.0)
          | mulss xmm0, xmm1    // xmm0 *= xmm1 (xmm0 *= 2.0)
          | jmp =>done // jmp done

          | =>no_shift:
          | cvtsi2ss xmm0, eax  // xmm0 = (float) eax

          | =>done:
          | movss dword [r_stack - sizeof(pwasm_val_t) + j * 4], xmm0
        }
      }

      break;
    case PWASM_OP_I32_LOAD:
    case PWASM_OP_I64_LOAD:
    case PWASM_OP_F32_LOAD:
    case PWASM_OP_F64_LOAD:
    case PWASM_OP_I32_LOAD8_S:
    case PWASM_OP_I32_LOAD8_U:
    case PWASM_OP_I32_LOAD16_S:
    case PWASM_OP_I32_LOAD16_U:
    case PWASM_OP_I64_LOAD8_S:
    case PWASM_OP_I64_LOAD8_U:
    case PWASM_OP_I64_LOAD16_S:
    case PWASM_OP_I64_LOAD16_U:
    case PWASM_OP_I64_LOAD32_S:
    case PWASM_OP_I64_LOAD32_U:
    case PWASM_OP_V128_LOAD:
      | mem_load
      break;
    case PWASM_OP_I32_STORE:
    case PWASM_OP_I64_STORE:
    case PWASM_OP_F32_STORE:
    case PWASM_OP_F64_STORE:
    case PWASM_OP_I32_STORE8:
    case PWASM_OP_I32_STORE16:
    case PWASM_OP_I64_STORE8:
    case PWASM_OP_I64_STORE16:
    case PWASM_OP_I64_STORE32:
    case PWASM_OP_V128_STORE:
      {
        // emit call
        | save_regs
        | mov r_arg0, r_env // environment
        | mov r_arg1, 1 // mem_id (FIXME)
        | mov r_arg2, in.op
        | mov r_arg3d, in.v_mem.offset
        | mov r_arg4d, in.v_mem.align
        | mov r_arg5, r_stack
        | sub r_arg5, 2 * sizeof(pwasm_val_t)
        | mov64 rax, (uintptr_t) pwasm_dynasm_jit_mem_store
        | call rax
        | restore_regs

        // check for error
        | cmp eax, 0
        | je ->exit_failure

        // pop two values from stack
        | stack_decn 2
      }

      break;
    case PWASM_OP_MEMORY_SIZE:
      | save_regs
      | mov r_arg0, r_env // environment
      | mov r_arg1, 1 // mem_id (FIXME)
      | mov r_arg2, r_stack // stack tail
      | mov64 rax, (uintptr_t) pwasm_env_mem_size
      | call rax
      | restore_regs

      // check for error
      | cmp eax, 0
      | je ->exit_failure

      // increment stack
      | stack_inc

      break;
    case PWASM_OP_MEMORY_GROW:
      | save_regs
      | mov r_arg0, r_env // environment
      | mov r_arg1, 1 // mem_id (FIXME)
      | mov r_arg2d, dword [r_stack - sizeof(pwasm_val_t)]
      | mov r_arg3, r_stack // stack tail
      | sub r_arg3, sizeof(pwasm_val_t)
      | mov64 rax, (uintptr_t) pwasm_env_mem_grow
      | call rax
      | restore_regs

      // check for error
      | cmp eax, 0
      | je ->exit_failure

      break;
    case PWASM_OP_V8X16_LOAD_SPLAT:
      | mem_load

      // splat
      | xor eax, eax
      | mov al, byte [r_stack - sizeof(pwasm_val_t)]
      | mov bl, al
      | shl bx, 8
      | or ax, bx
      | mov bx, ax
      | shl ebx, 16
      | or eax, ebx
      for (size_t j = 0; j < 4; j++) {
        | mov dword [r_stack - sizeof(pwasm_val_t) + j], eax
      }

      break;
    case PWASM_OP_V16X8_LOAD_SPLAT:
      | mem_load
      // splat
      | xor eax, eax
      | mov ax, word [r_stack - sizeof(pwasm_val_t)]
      | mov bx, ax
      | shl ebx, 16
      | or eax, ebx
      for (size_t j = 0; j < 4; j++) {
        | mov dword [r_stack - sizeof(pwasm_val_t) + j], eax
      }

      break;
    case PWASM_OP_V32X4_LOAD_SPLAT:
      | mem_load
      // splat
      | mov eax, dword [r_stack - sizeof(pwasm_val_t)]
      for (size_t j = 0; j < 4; j++) {
        | mov dword [r_stack - sizeof(pwasm_val_t) + j], eax
      }

      break;
    case PWASM_OP_V64X2_LOAD_SPLAT:
      | mem_load
      | mov rax, qword [r_stack - sizeof(pwasm_val_t)]
      | mov [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)], rax

      break;
    case PWASM_OP_I16X8_LOAD8X8_S:
      | mem_load
      | pmovsxbw xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_I16X8_LOAD8X8_U:
      | mem_load
      | pmovzxbw xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_I32X4_LOAD16X4_S:
      | mem_load
      | pmovsxwd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_I32X4_LOAD16X4_U:
      | mem_load
      | pmovzxwd xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_I64X2_LOAD32X2_S:
      | mem_load
      | pmovsxdq xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    case PWASM_OP_I64X2_LOAD32X2_U:
      | mem_load
      | pmovzxdq xmm0, qword [r_stack - sizeof(pwasm_val_t)]
      | movdqu [r_stack - sizeof(pwasm_val_t)], xmm0

      break;
    default:
      {
        // log error
        char buf[512];
        snprintf(buf, sizeof(buf), "unimplemented opcode: 0x%08x", in.op);
        fail(env, buf);

        // return failure
        return false;
      }
    }
  }

  // emit exit_success
  | ->exit_success:

  // save stack depth
  | stack_save_depth

  // return success
  | mov rax, 1
  | ret

  // emit exit_failure
  | ->exit_failure:
  | mov rax, 0
  | ret

  // get needed size
  size_t num_bytes;
  if (dasm_link(&dasm, &num_bytes)) {
    fail(env, "dasm_link() failed");
    return false;
  }

  // map memory, check for error
  void *ptr = mmap(NULL, num_bytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (!ptr) {
    // log error, return failure
    fail(env, "dasm_link() failed");
    return false;
  }

  // encode, check for error
  if (dasm_encode(&dasm, ptr)) {
    // log error, return failure
    fail(env, "dasm_encode() failed");
    return false;
  }

  // finalize dynasm state
  dasm_free(&dasm);

  // finalize control stack
  pwasm_ctrl_stack_fini(&ctrl_stack);

  // protect memory
  if (mprotect(ptr, num_bytes, PROT_READ | PROT_EXEC)) {
    // log error, return failure
    fail(env, "mprotect() failed");
    return false;
  }

  // populate result
  D("dst = %p, buf = { 0x%p, %zu }", (void*) dst, ptr, num_bytes);
  dst->ptr = ptr;
  dst->len = num_bytes;

  #ifdef PWASM_DEBUG
  // dump buffer
  pwasm_dump(env, mod_id, func_ofs, *dst);
  #endif /* PWASM_DEBUG */

  // return success
  return true;
}

static void
pwasm_dynasm_jit_on_fini(
  pwasm_jit_t * const jit
) {
  if (jit->data) {
    // free memory, zero pointer
    pwasm_realloc(jit->mem_ctx, jit->data, 0);
    jit->data = NULL;
  }
}

static const pwasm_jit_cbs_t
PWASM_DYNASM_JIT_CBS = {
  .compile  = pwasm_dynasm_jit_on_compile,
  .fini     = pwasm_dynasm_jit_on_fini,
};

bool
pwasm_dynasm_jit_init(
  pwasm_jit_t *jit, ///< destination JIT compiler
  pwasm_mem_ctx_t *mem_ctx  ///< memory context
) {
  // TODO: check cpuid here

  // allocate jit data, check for error
  pwasm_dynasm_jit_t *data = pwasm_realloc(mem_ctx, 0, sizeof(pwasm_dynasm_jit_t));
  if (!data) {
    pwasm_fail(mem_ctx, "pwasm_realloc() failed");
    return false;
  }

  // populate result
  *jit = (pwasm_jit_t) {
    .mem_ctx  = mem_ctx,
    .cbs      = &PWASM_DYNASM_JIT_CBS,
    .data     = data,
  };

  // return success
  return true;
}

// vi: syntax=c
