#include <stdbool.h> // bool
#include <stdlib.h> // EXIT_FAILURE
#include <stdio.h> // snprintf
#include <string.h> // strlen()
#include <err.h> // errx()
#include "../tests.h"
#include "../result-type.h"
#include "../../pwasm.h"
#include "../../pwasm-compile.h"

#define LEN(ary) (sizeof(ary) / sizeof(ary[0]))

// are two floats/doubles approximately equal?
#define NEARLY_EQUAL(a, b) (((a) - 0.00001 <= (b)) && ((a) + 0.00001 >= (b)))

// maximum test stack depth
#define MAX_STACK_DEPTH 100

// aot.wasm: basic aot tests
// generated by: xxd -c 8 -i data/wat/17-aot.wasm
// (source: data/wat/17-aot.wat)
static const uint8_t AOT_WASM[] = {
  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x14, 0x04, 0x60, 0x00, 0x01, 0x7f, 0x60,
  0x01, 0x7f, 0x01, 0x7f, 0x60, 0x02, 0x7f, 0x7f,
  0x01, 0x7f, 0x60, 0x01, 0x7f, 0x00, 0x03, 0x0e,
  0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x01, 0x00, 0x03, 0x01, 0x06, 0x06,
  0x01, 0x7f, 0x01, 0x41, 0x2a, 0x0b, 0x07, 0x89,
  0x01, 0x0d, 0x08, 0x61, 0x64, 0x64, 0x5f, 0x69,
  0x33, 0x32, 0x73, 0x00, 0x00, 0x04, 0x74, 0x72,
  0x61, 0x70, 0x00, 0x01, 0x0c, 0x69, 0x66, 0x5f,
  0x65, 0x6c, 0x73, 0x65, 0x5f, 0x74, 0x72, 0x75,
  0x65, 0x00, 0x02, 0x0d, 0x69, 0x66, 0x5f, 0x65,
  0x6c, 0x73, 0x65, 0x5f, 0x66, 0x61, 0x6c, 0x73,
  0x65, 0x00, 0x03, 0x07, 0x69, 0x66, 0x5f, 0x74,
  0x72, 0x75, 0x65, 0x00, 0x04, 0x08, 0x69, 0x66,
  0x5f, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x00, 0x05,
  0x08, 0x62, 0x72, 0x5f, 0x6f, 0x75, 0x74, 0x65,
  0x72, 0x00, 0x06, 0x08, 0x62, 0x72, 0x5f, 0x69,
  0x6e, 0x6e, 0x65, 0x72, 0x00, 0x07, 0x03, 0x73,
  0x75, 0x62, 0x00, 0x08, 0x05, 0x69, 0x73, 0x5f,
  0x39, 0x39, 0x00, 0x09, 0x07, 0x69, 0x33, 0x32,
  0x5f, 0x67, 0x65, 0x74, 0x00, 0x0a, 0x07, 0x69,
  0x33, 0x32, 0x5f, 0x73, 0x65, 0x74, 0x00, 0x0b,
  0x07, 0x69, 0x33, 0x32, 0x5f, 0x65, 0x71, 0x7a,
  0x00, 0x0c, 0x0a, 0x85, 0x01, 0x0d, 0x09, 0x00,
  0x41, 0xfb, 0x00, 0x41, 0xc8, 0x03, 0x6a, 0x0b,
  0x03, 0x00, 0x00, 0x0b, 0x0e, 0x00, 0x41, 0x01,
  0x04, 0x7f, 0x41, 0xc1, 0x02, 0x05, 0x41, 0xc8,
  0x03, 0x0b, 0x0b, 0x0c, 0x00, 0x41, 0x00, 0x04,
  0x7f, 0x41, 0x20, 0x05, 0x41, 0x2d, 0x0b, 0x0b,
  0x0f, 0x00, 0x41, 0x80, 0x08, 0x41, 0x01, 0x04,
  0x01, 0x1a, 0x41, 0xaf, 0x96, 0x13, 0x0b, 0x0b,
  0x0c, 0x00, 0x41, 0x16, 0x41, 0x00, 0x04, 0x01,
  0x1a, 0x41, 0x2c, 0x0b, 0x0b, 0x08, 0x00, 0x41,
  0xd2, 0x09, 0x0c, 0x00, 0x00, 0x0b, 0x0b, 0x00,
  0x41, 0xae, 0x2c, 0x02, 0x40, 0x0c, 0x00, 0x00,
  0x0b, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x6b, 0x0b, 0x0d, 0x00, 0x41, 0x00, 0x41, 0x01,
  0x41, 0xe3, 0x00, 0x20, 0x00, 0x6b, 0x1b, 0x0b,
  0x04, 0x00, 0x23, 0x00, 0x0b, 0x06, 0x00, 0x20,
  0x00, 0x24, 0x00, 0x0b, 0x05, 0x00, 0x20, 0x00,
  0x45, 0x0b
};

static const pwasm_val_t
TEST_VALS[] = {
  // mod: "aot", func: "add_i32s", test: 0, params: 0, results: 1
  { .i32 = 579 },

  // mod: "aot", func: "if_else_true", test: 0, params: 0, results: 1
  { .i32 = 321 },

  // mod: "aot", func: "if_else_false", test: 0, params: 0, results: 1
  { .i32 = 45 },

  // mod: "aot", func: "if_true", test: 0, params: 0, results: 1
  { .i32 = 314159 },

  // mod: "aot", func: "if_false", test: 0, params: 0, results: 1
  { .i32 = 22 },

  // mod: "aot", func: "br_outer", test: 0, params: 0, results: 1
  { .i32 = 1234 },

  // mod: "aot", func: "br_inner", test: 0, params: 0, results: 1
  { .i32 = 5678 },

  // mod: "aot", func: "sub", test: 0, params: 2, results: 1
  { .i32 = 99 },
  { .i32 = 77 },
  { .i32 = 22 },

  // mod: "aot", func: "is_99", test: 0, params: 1, results: 1
  { .i32 = 99 },
  { .i32 = 1 },

  // mod: "aot", func: "is_99", test: 0, params: 1, results: 1
  { .i32 = 2 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_eqz", test: 0, params: 1, results: 1
  { .i32 = 0 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_eqz", test: 1, params: 1, results: 1
  { .i32 = 1 },
  { .i32 = 0 },
};

static const pwasm_value_type_t
TEST_TYPES[] = {
  // mod: "aot", func: "add_i32s", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_else_true", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_else_false", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_true", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_false", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "br_outer", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "br_inner", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "sub", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "is_99", test: 0, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "is_99", test: 1, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_eqz", test: 0, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_eqz", test: 1, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
};

typedef struct {
  const char * const mod;
  const char * const func;
  const bool fails;
  const pwasm_slice_t params;
  const pwasm_slice_t results;
} test_call_t;

static const test_call_t
TEST_CALLS[] = {{
  .mod      = "aot",
  .func     = "add_i32s",
  .results  = { 0, 1 },
}, {
  .mod      = "aot",
  .func     = "trap",
  .fails    = true,
}, {
  .mod      = "aot",
  .func     = "if_else_true",
  .results  = { 1, 1 },
}, {
  .mod      = "aot",
  .func     = "if_else_false",
  .results  = { 2, 1 },
}, {
  .mod      = "aot",
  .func     = "if_true",
  .results  = { 3, 1 },
}, {
  .mod      = "aot",
  .func     = "if_false",
  .results  = { 4, 1 },
}, {
  .mod      = "aot",
  .func     = "br_outer",
  .results  = { 5, 1 },
}, {
  .mod      = "aot",
  .func     = "br_inner",
  .results  = { 6, 1 },
}, {
  .mod      = "aot",
  .func     = "sub",
  .params  = { 7, 2 },
  .results = { 9, 1 },
}, {
  .mod      = "aot",
  .func     = "is_99",
  .params  = { 10, 1 },
  .results = { 11, 1 },
}, {
  .mod      = "aot",
  .func     = "is_99",
  .params  = { 12, 1 },
  .results = { 13, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_eqz",
  .params  = { 14, 1 },
  .results = { 15, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_eqz",
  .params  = { 16, 1 },
  .results = { 17, 1 },
}};

static size_t get_test_name(
  char * const dst,
  const test_call_t test
) {
  const size_t mod_len = strlen(test.mod);
  const size_t func_len = strlen(test.func);
  size_t ofs = 0;

  memcpy(dst, test.mod, mod_len);
  ofs += mod_len;

  dst[ofs] = '.';
  ofs += 1;

  memcpy(dst + ofs, test.func, func_len);
  ofs += func_len;

  dst[ofs] = '(';
  ofs += 1;

  for (size_t i = 0; i < test.params.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.params.ofs + i];

    switch (type) {
    case PWASM_VALUE_TYPE_I32:
      ofs += sprintf(dst + ofs, "%s%u", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].i32);
      break;
    case PWASM_VALUE_TYPE_I64:
      ofs += sprintf(dst + ofs, "%s%lu", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].i64);
      break;
    case PWASM_VALUE_TYPE_F32:
      ofs += sprintf(dst + ofs, "%s%f", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].f32);
      break;
    case PWASM_VALUE_TYPE_F64:
      ofs += sprintf(dst + ofs, "%s%f", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].f64);
      break;
    default:
      // never reached
      errx(EXIT_FAILURE, "unknown value type: %u", type);
    }
  }

  memcpy(dst + ofs, "), [", 4);
  ofs += 4;

  for (size_t i = 0; i < test.params.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.params.ofs + i];
    const char * const name = pwasm_value_type_get_name(type);
    const size_t name_len = strlen(name);

    if (i > 0) {
      dst[ofs] = ',';
      dst[ofs + 1] = ' ';
      ofs += 2;
    }

    memcpy(dst + ofs, name, name_len);
    ofs += name_len;
  }

  memcpy(dst + ofs, "] -> [", 6);
  ofs += 6;

  for (size_t i = 0; i < test.results.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.results.ofs + i];
    const char * const name = pwasm_value_type_get_name(type);
    const size_t name_len = strlen(name);

    if (i > 0) {
      dst[ofs] = ',';
      dst[ofs + 1] = ' ';
      ofs += 2;
    }

    memcpy(dst + ofs, name, name_len);
    ofs += name_len;
  }

  dst[ofs] = ']';
  ofs += 1;

  // terminate
  dst[ofs] = '\0';

  // return name length, excluding null byte
  return ofs;
}

static void check_results(
  cli_test_ctx_t * const test_ctx,
  const cli_test_t * const cli_test,
  const test_call_t test,
  const char * const test_name,
  const pwasm_stack_t * const stack
) {
  char buf[1024];
  char name_buf[512];

  for (size_t i = 0; i < test.results.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.results.ofs + i];
    const char * const type_name = pwasm_value_type_get_name(type);
    const pwasm_val_t got_val = stack->ptr[i];
    const pwasm_val_t exp_val = TEST_VALS[test.results.ofs + i];

    snprintf(name_buf, sizeof(name_buf), "%s: check results[%zu].%s", test_name, i, type_name);

    switch (type) {
    case PWASM_VALUE_TYPE_I32:
      if (got_val.i32 == exp_val.i32) {
        // build pass text
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // build fail text
        snprintf(buf, sizeof(buf), "%s failed: got 0x%08x, expected 0x%08x", name_buf, got_val.i32, exp_val.i32);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    case PWASM_VALUE_TYPE_I64:
      if (got_val.i64 == exp_val.i64) {
        // build pass text
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // build fail text
        snprintf(buf, sizeof(buf), "%s failed: got 0x%016lx, expected 0x%016lx", name_buf, got_val.i64, exp_val.i64);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    case PWASM_VALUE_TYPE_F32:
      if (NEARLY_EQUAL(got_val.f32, exp_val.f32)) {
        // pass assertion
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // fail assertion
        snprintf(buf, sizeof(buf), "%s failed: got %f, expected %f", name_buf, got_val.f32, exp_val.f32);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    case PWASM_VALUE_TYPE_F64:
      if (NEARLY_EQUAL(got_val.f64, exp_val.f64)) {
        // pass assertion
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // fail assertion
        snprintf(buf, sizeof(buf), "%s failed: got %f, expected %f", name_buf, got_val.f64, exp_val.f64);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    default:
      // never reached
      snprintf(buf, sizeof(buf), "unknown value type: %u", type);
      cli_test_error(test_ctx, buf);
      return;
    }
  }
}

void test_compile(
  cli_test_ctx_t * const test_ctx,
  const cli_test_t * const cli_test
) {
  // create a memory context
  pwasm_mem_ctx_t mem_ctx = pwasm_mem_ctx_init_defaults(NULL);

  // set up stack
  pwasm_val_t stack_vals[MAX_STACK_DEPTH];
  pwasm_stack_t stack = {
    .ptr = stack_vals,
    .len = MAX_STACK_DEPTH,
  };

  // get interpreter callbacks
  pwasm_env_cbs_t cbs;
  pwasm_aot_jit_get_cbs(&cbs, pwasm_compile);

  // create environment, check for error
  pwasm_env_t env;
  if (!pwasm_env_init(&env, &mem_ctx, &cbs, &stack, NULL)) {
    cli_test_error(test_ctx, "pwasm_env_init() failed");
    return;
  }

  // build buffer
  const pwasm_buf_t buf = { AOT_WASM, sizeof(AOT_WASM) };

  // parse mod, check for error
  pwasm_mod_t mod;
  if (!pwasm_mod_init(&mem_ctx, &mod, buf)) {
    cli_test_error(test_ctx, "pwasm_mod_init() failed");
    return;
  }

  // add mod to env, check for error
  if (!pwasm_env_add_mod(&env, "aot", &mod)) {
    cli_test_error(test_ctx, "pwasm_env_add_mod() failed");
    return;
  }

  for (size_t i = 0; i < LEN(TEST_CALLS); i++) {
    const test_call_t test = TEST_CALLS[i];

    // populate stack
    stack.pos = test.params.len;
    if (test.params.len > 0) {
      const size_t num_bytes =  test.params.len * sizeof(pwasm_val_t);
      memcpy(stack.ptr, TEST_VALS + test.params.ofs, num_bytes);
    }

    char name_buf[512];
    char buf[1024];
    get_test_name(name_buf, test);

    // call function, check result
    const bool call_ok = (pwasm_call(&env, test.mod, test.func) != test.fails);
    if (call_ok) {
      snprintf(buf, sizeof(buf), "%s: call passed", name_buf);
      cli_test_pass(test_ctx, cli_test, buf);
    } else {
      snprintf(buf, sizeof(buf), "%s: call failed", name_buf);
      cli_test_fail(test_ctx, cli_test, buf);
    }

    // check stack size
    if (call_ok && !test.fails) {
      if (stack.pos == test.results.len) {
        snprintf(buf, sizeof(buf), "%s: stack size == %zu", name_buf, stack.pos);
        cli_test_pass(test_ctx, cli_test, buf);
      } else {
        snprintf(buf, sizeof(buf), "%s: stack size: got %zu, expected %zu", name_buf, stack.pos, test.results.len);
        cli_test_fail(test_ctx, cli_test, buf);
      }
    } else if (call_ok && test.fails) {
      snprintf(buf, sizeof(buf), "%s: stack size: n/a", name_buf);
      cli_test_pass(test_ctx, cli_test, buf);
    } else {
      snprintf(buf, sizeof(buf), "%s: stack size: call failed", name_buf);
      cli_test_fail(test_ctx, cli_test, buf);
    }

    if (call_ok && !test.fails) {
      check_results(test_ctx, cli_test, test, name_buf, &stack);
    }
  }
}
