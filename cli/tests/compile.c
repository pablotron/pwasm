#include <stdbool.h> // bool
#include <stdlib.h> // EXIT_FAILURE
#include <stdio.h> // snprintf
#include <string.h> // strlen()
#include <err.h> // errx()
#include "../tests.h"
#include "../result-type.h"
#include "../../pwasm.h"
#include "../../pwasm-compile.h"

#define LEN(ary) (sizeof(ary) / sizeof(ary[0]))

// are two floats/doubles approximately equal?
#define NEARLY_EQUAL(a, b) (((a) - 0.00001 <= (b)) && ((a) + 0.00001 >= (b)))

// maximum test stack depth
#define MAX_STACK_DEPTH 100

// aot.wasm: basic aot tests
// generated by: xxd -c 8 -i data/wat/17-aot.wasm
// (source: data/wat/17-aot.wat)
static const uint8_t AOT_WASM[] = {
  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x25, 0x07, 0x60, 0x00, 0x01, 0x7f, 0x60,
  0x01, 0x7f, 0x01, 0x7f, 0x60, 0x02, 0x7f, 0x7f,
  0x01, 0x7f, 0x60, 0x01, 0x7f, 0x00, 0x60, 0x01,
  0x7e, 0x01, 0x7f, 0x60, 0x02, 0x7e, 0x7e, 0x01,
  0x7f, 0x60, 0x02, 0x7d, 0x7d, 0x01, 0x7f, 0x03,
  0x29, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x01, 0x00, 0x03, 0x01, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
  0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
  0x06, 0x06, 0x06, 0x06, 0x01, 0x7f, 0x01, 0x41,
  0x2a, 0x0b, 0x07, 0x9d, 0x03, 0x28, 0x08, 0x61,
  0x64, 0x64, 0x5f, 0x69, 0x33, 0x32, 0x73, 0x00,
  0x00, 0x04, 0x74, 0x72, 0x61, 0x70, 0x00, 0x01,
  0x0c, 0x69, 0x66, 0x5f, 0x65, 0x6c, 0x73, 0x65,
  0x5f, 0x74, 0x72, 0x75, 0x65, 0x00, 0x02, 0x0d,
  0x69, 0x66, 0x5f, 0x65, 0x6c, 0x73, 0x65, 0x5f,
  0x66, 0x61, 0x6c, 0x73, 0x65, 0x00, 0x03, 0x07,
  0x69, 0x66, 0x5f, 0x74, 0x72, 0x75, 0x65, 0x00,
  0x04, 0x08, 0x69, 0x66, 0x5f, 0x66, 0x61, 0x6c,
  0x73, 0x65, 0x00, 0x05, 0x08, 0x62, 0x72, 0x5f,
  0x6f, 0x75, 0x74, 0x65, 0x72, 0x00, 0x06, 0x08,
  0x62, 0x72, 0x5f, 0x69, 0x6e, 0x6e, 0x65, 0x72,
  0x00, 0x07, 0x03, 0x73, 0x75, 0x62, 0x00, 0x08,
  0x05, 0x69, 0x73, 0x5f, 0x39, 0x39, 0x00, 0x09,
  0x07, 0x69, 0x33, 0x32, 0x5f, 0x67, 0x65, 0x74,
  0x00, 0x0a, 0x07, 0x69, 0x33, 0x32, 0x5f, 0x73,
  0x65, 0x74, 0x00, 0x0b, 0x07, 0x69, 0x33, 0x32,
  0x5f, 0x65, 0x71, 0x7a, 0x00, 0x0c, 0x06, 0x69,
  0x33, 0x32, 0x5f, 0x65, 0x71, 0x00, 0x0d, 0x06,
  0x69, 0x33, 0x32, 0x5f, 0x6e, 0x65, 0x00, 0x0e,
  0x08, 0x69, 0x33, 0x32, 0x5f, 0x6c, 0x74, 0x5f,
  0x73, 0x00, 0x0f, 0x08, 0x69, 0x33, 0x32, 0x5f,
  0x6c, 0x74, 0x5f, 0x75, 0x00, 0x10, 0x08, 0x69,
  0x33, 0x32, 0x5f, 0x67, 0x74, 0x5f, 0x73, 0x00,
  0x11, 0x08, 0x69, 0x33, 0x32, 0x5f, 0x67, 0x74,
  0x5f, 0x75, 0x00, 0x12, 0x08, 0x69, 0x33, 0x32,
  0x5f, 0x6c, 0x65, 0x5f, 0x73, 0x00, 0x13, 0x08,
  0x69, 0x33, 0x32, 0x5f, 0x6c, 0x65, 0x5f, 0x75,
  0x00, 0x14, 0x08, 0x69, 0x33, 0x32, 0x5f, 0x67,
  0x65, 0x5f, 0x73, 0x00, 0x15, 0x08, 0x69, 0x33,
  0x32, 0x5f, 0x67, 0x65, 0x5f, 0x75, 0x00, 0x16,
  0x07, 0x69, 0x36, 0x34, 0x5f, 0x65, 0x71, 0x7a,
  0x00, 0x17, 0x06, 0x69, 0x36, 0x34, 0x5f, 0x65,
  0x71, 0x00, 0x18, 0x06, 0x69, 0x36, 0x34, 0x5f,
  0x6e, 0x65, 0x00, 0x19, 0x08, 0x69, 0x36, 0x34,
  0x5f, 0x6c, 0x74, 0x5f, 0x73, 0x00, 0x1a, 0x08,
  0x69, 0x36, 0x34, 0x5f, 0x6c, 0x74, 0x5f, 0x75,
  0x00, 0x1b, 0x08, 0x69, 0x36, 0x34, 0x5f, 0x67,
  0x74, 0x5f, 0x73, 0x00, 0x1c, 0x08, 0x69, 0x36,
  0x34, 0x5f, 0x67, 0x74, 0x5f, 0x75, 0x00, 0x1d,
  0x08, 0x69, 0x36, 0x34, 0x5f, 0x6c, 0x65, 0x5f,
  0x73, 0x00, 0x1e, 0x08, 0x69, 0x36, 0x34, 0x5f,
  0x6c, 0x65, 0x5f, 0x75, 0x00, 0x1f, 0x08, 0x69,
  0x36, 0x34, 0x5f, 0x67, 0x65, 0x5f, 0x73, 0x00,
  0x20, 0x08, 0x69, 0x36, 0x34, 0x5f, 0x67, 0x65,
  0x5f, 0x75, 0x00, 0x21, 0x06, 0x66, 0x33, 0x32,
  0x5f, 0x65, 0x71, 0x00, 0x22, 0x06, 0x66, 0x33,
  0x32, 0x5f, 0x6e, 0x65, 0x00, 0x23, 0x06, 0x66,
  0x33, 0x32, 0x5f, 0x6c, 0x74, 0x00, 0x24, 0x06,
  0x66, 0x33, 0x32, 0x5f, 0x67, 0x74, 0x00, 0x25,
  0x06, 0x66, 0x33, 0x32, 0x5f, 0x6c, 0x65, 0x00,
  0x26, 0x06, 0x66, 0x33, 0x32, 0x5f, 0x67, 0x65,
  0x00, 0x27, 0x0a, 0xdb, 0x02, 0x28, 0x09, 0x00,
  0x41, 0xfb, 0x00, 0x41, 0xc8, 0x03, 0x6a, 0x0b,
  0x03, 0x00, 0x00, 0x0b, 0x0e, 0x00, 0x41, 0x01,
  0x04, 0x7f, 0x41, 0xc1, 0x02, 0x05, 0x41, 0xc8,
  0x03, 0x0b, 0x0b, 0x0c, 0x00, 0x41, 0x00, 0x04,
  0x7f, 0x41, 0x20, 0x05, 0x41, 0x2d, 0x0b, 0x0b,
  0x0f, 0x00, 0x41, 0x80, 0x08, 0x41, 0x01, 0x04,
  0x01, 0x1a, 0x41, 0xaf, 0x96, 0x13, 0x0b, 0x0b,
  0x0c, 0x00, 0x41, 0x16, 0x41, 0x00, 0x04, 0x01,
  0x1a, 0x41, 0x2c, 0x0b, 0x0b, 0x08, 0x00, 0x41,
  0xd2, 0x09, 0x0c, 0x00, 0x00, 0x0b, 0x0b, 0x00,
  0x41, 0xae, 0x2c, 0x02, 0x40, 0x0c, 0x00, 0x00,
  0x0b, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x6b, 0x0b, 0x0d, 0x00, 0x41, 0x00, 0x41, 0x01,
  0x41, 0xe3, 0x00, 0x20, 0x00, 0x6b, 0x1b, 0x0b,
  0x04, 0x00, 0x23, 0x00, 0x0b, 0x06, 0x00, 0x20,
  0x00, 0x24, 0x00, 0x0b, 0x05, 0x00, 0x20, 0x00,
  0x45, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x46, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x47, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x48, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x49, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x4a, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x4b, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x4c, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x4d, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x4e, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01,
  0x4f, 0x0b, 0x05, 0x00, 0x20, 0x00, 0x50, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x51, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x52, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x53, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x54, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x55, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x56, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x57, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x58, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x59, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x5a, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x5b, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x5c, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x5d, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x5e, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x5f, 0x0b,
  0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x60, 0x0b
};

static const pwasm_val_t
TEST_VALS[] = {
  // mod: "aot", func: "add_i32s", test: 0, params: 0, results: 1
  { .i32 = 579 },

  // mod: "aot", func: "if_else_true", test: 0, params: 0, results: 1
  { .i32 = 321 },

  // mod: "aot", func: "if_else_false", test: 0, params: 0, results: 1
  { .i32 = 45 },

  // mod: "aot", func: "if_true", test: 0, params: 0, results: 1
  { .i32 = 314159 },

  // mod: "aot", func: "if_false", test: 0, params: 0, results: 1
  { .i32 = 22 },

  // mod: "aot", func: "br_outer", test: 0, params: 0, results: 1
  { .i32 = 1234 },

  // mod: "aot", func: "br_inner", test: 0, params: 0, results: 1
  { .i32 = 5678 },

  // mod: "aot", func: "sub", test: 0, params: 2, results: 1
  { .i32 = 99 },
  { .i32 = 77 },
  { .i32 = 22 },

  // mod: "aot", func: "is_99", test: 0, params: 1, results: 1
  { .i32 = 99 },
  { .i32 = 1 },

  // mod: "aot", func: "is_99", test: 0, params: 1, results: 1
  { .i32 = 2 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_eqz", test: 0, params: 1, results: 1
  { .i32 = 0 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_eqz", test: 1, params: 1, results: 1
  { .i32 = 1 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_eq", test: 0, params: 2, results: 1
  { .i32 = 314 },
  { .i32 = 314 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_eq", test: 1, params: 2, results: 1
  { .i32 = 123 },
  { .i32 = 456 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_ne", test: 0, params: 2, results: 1
  { .i32 = 654 },
  { .i32 = 789 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_ne", test: 1, params: 2, results: 1
  { .i32 = 44422 },
  { .i32 = 44422 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_lt_s", test: 0, params: 2, results: 1
  { .i32 = -22 },
  { .i32 = 44 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_lt_s", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_lt_s", test: 2, params: 2, results: 1
  { .i32 = 2020 },
  { .i32 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_lt_u", test: 0, params: 2, results: 1
  { .i32 = 12 },
  { .i32 = (1UL << 31) },
  { .i32 = 1 },

  // mod: "aot", func: "i32_lt_u", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_lt_u", test: 2, params: 2, results: 1
  { .i32 = 2020 },
  { .i32 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_gt_s", test: 0, params: 2, results: 1
  { .i32 = 22 },
  { .i32 = -44 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_gt_s", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_gt_s", test: 2, params: 2, results: 1
  { .i32 = 123 },
  { .i32 = 4212 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_gt_u", test: 0, params: 2, results: 1
  { .i32 = (1UL << 31) },
  { .i32 = 12 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_gt_u", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_gt_u", test: 2, params: 2, results: 1
  { .i32 = 5 },
  { .i32 = 2020 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_le_s", test: 0, params: 2, results: 1
  { .i32 = -22 },
  { .i32 = 44 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_le_s", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_le_s", test: 2, params: 2, results: 1
  { .i32 = 2020 },
  { .i32 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_le_u", test: 0, params: 2, results: 1
  { .i32 = 12 },
  { .i32 = (1UL << 31) },
  { .i32 = 1 },

  // mod: "aot", func: "i32_le_u", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_le_u", test: 2, params: 2, results: 1
  { .i32 = 2020 },
  { .i32 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_ge_s", test: 0, params: 2, results: 1
  { .i32 = 22 },
  { .i32 = -44 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_ge_s", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_ge_s", test: 2, params: 2, results: 1
  { .i32 = 2 },
  { .i32 = 3030 },
  { .i32 = 0 },

  // mod: "aot", func: "i32_ge_u", test: 0, params: 2, results: 1
  { .i32 = (1UL << 31) },
  { .i32 = 9 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_ge_u", test: 1, params: 2, results: 1
  { .i32 = 4122 },
  { .i32 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i32_ge_u", test: 2, params: 2, results: 1
  { .i32 = 0 },
  { .i32 = 5053 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_eqz", test: 0, params: 1, results: 1
  { .i64 = 0 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_eqz", test: 1, params: 1, results: 1
  { .i64 = 1 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_eq", test: 0, params: 2, results: 1
  { .i64 = 314 },
  { .i64 = 314 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_eq", test: 1, params: 2, results: 1
  { .i64 = 123 },
  { .i64 = 456 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_ne", test: 0, params: 2, results: 1
  { .i64 = 654 },
  { .i64 = 789 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_ne", test: 1, params: 2, results: 1
  { .i64 = 44422 },
  { .i64 = 44422 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_lt_s", test: 0, params: 2, results: 1
  { .i64 = -22 },
  { .i64 = 44 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_lt_s", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_lt_s", test: 2, params: 2, results: 1
  { .i64 = 2020 },
  { .i64 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_lt_u", test: 0, params: 2, results: 1
  { .i64 = 12 },
  { .i64 = (1UL << 31) },
  { .i32 = 1 },

  // mod: "aot", func: "i64_lt_u", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_lt_u", test: 2, params: 2, results: 1
  { .i64 = 2020 },
  { .i64 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_gt_s", test: 0, params: 2, results: 1
  { .i64 = 22 },
  { .i64 = -44 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_gt_s", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_gt_s", test: 2, params: 2, results: 1
  { .i64 = 123 },
  { .i64 = 4212 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_gt_u", test: 0, params: 2, results: 1
  { .i64 = (1UL << 31) },
  { .i64 = 12 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_gt_u", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_gt_u", test: 2, params: 2, results: 1
  { .i64 = 5 },
  { .i64 = 2020 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_le_s", test: 0, params: 2, results: 1
  { .i64 = -22 },
  { .i64 = 44 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_le_s", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_le_s", test: 2, params: 2, results: 1
  { .i64 = 2020 },
  { .i64 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_le_u", test: 0, params: 2, results: 1
  { .i64 = 12 },
  { .i64 = (1UL << 31) },
  { .i32 = 1 },

  // mod: "aot", func: "i64_le_u", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_le_u", test: 2, params: 2, results: 1
  { .i64 = 2020 },
  { .i64 = 5 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_ge_s", test: 0, params: 2, results: 1
  { .i64 = 22 },
  { .i64 = -44 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_ge_s", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_ge_s", test: 2, params: 2, results: 1
  { .i64 = 2 },
  { .i64 = 3030 },
  { .i32 = 0 },

  // mod: "aot", func: "i64_ge_u", test: 0, params: 2, results: 1
  { .i64 = (1UL << 31) },
  { .i64 = 9 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_ge_u", test: 1, params: 2, results: 1
  { .i64 = 4122 },
  { .i64 = 4122 },
  { .i32 = 1 },

  // mod: "aot", func: "i64_ge_u", test: 2, params: 2, results: 1
  { .i64 = 0 },
  { .i64 = 5053 },
  { .i32 = 0 },

  // mod: "aot", func: "f32_eq", test: 0, params: 2, results: 1
  { .f32 = 1.0f },
  { .f32 = 1.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_eq", test: 1, params: 2, results: 1
  { .f32 = 2.0f },
  { .f32 = 1.0f },
  { .i32 = 0 },

  // mod: "aot", func: "f32_ne", test: 0, params: 2, results: 1
  { .f32 = -1.0f },
  { .f32 = 1.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_ne", test: 1, params: 2, results: 1
  { .f32 = 2.0f },
  { .f32 = 2.0f },
  { .i32 = 0 },

  // mod: "aot", func: "f32_lt", test: 0, params: 2, results: 1
  { .f32 = -1.0f },
  { .f32 = 1.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_lt", test: 1, params: 2, results: 1
  { .f32 = 2.0f },
  { .f32 = 2.0f },
  { .i32 = 0 },

  // mod: "aot", func: "f32_gt", test: 0, params: 2, results: 1
  { .f32 = 10.0f },
  { .f32 = 1.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_gt", test: 1, params: 2, results: 1
  { .f32 = 3.0f },
  { .f32 = 3.0f },
  { .i32 = 0 },

  // mod: "aot", func: "f32_le", test: 0, params: 2, results: 1
  { .f32 = -1.0f },
  { .f32 = 1.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_le", test: 1, params: 2, results: 1
  { .f32 = 2.0f },
  { .f32 = 2.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_ge", test: 0, params: 2, results: 1
  { .f32 = 10.0f },
  { .f32 = 1.0f },
  { .i32 = 1 },

  // mod: "aot", func: "f32_ge", test: 1, params: 2, results: 1
  { .f32 = 3.0f },
  { .f32 = 3.0f },
  { .i32 = 1 },
};

static const pwasm_value_type_t
TEST_TYPES[] = {
  // mod: "aot", func: "add_i32s", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_else_true", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_else_false", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_true", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "if_false", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "br_outer", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "br_inner", test: 0, params: 0, results: 1
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "sub", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "is_99", test: 0, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "is_99", test: 1, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_eqz", test: 0, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_eqz", test: 1, params: 1, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_eq", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_eq", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ne", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ne", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_lt_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_lt_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_lt_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_lt_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_lt_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_lt_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_gt_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_gt_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_gt_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_gt_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_gt_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_gt_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_le_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_le_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_le_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_le_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_le_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_le_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ge_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ge_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ge_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ge_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ge_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i32_ge_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_eqz", test: 0, params: 1, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_eqz", test: 1, params: 1, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_eq", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_eq", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ne", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ne", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_lt_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_lt_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_lt_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_lt_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_lt_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_lt_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_gt_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_gt_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_gt_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_gt_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_gt_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_gt_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_le_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_le_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_le_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_le_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_le_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_le_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ge_s", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ge_s", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ge_s", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ge_u", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ge_u", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "i64_ge_u", test: 2, params: 2, results: 1
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I64,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_eq", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_eq", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_ne", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_ne", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_lt", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_lt", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_gt", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_gt", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_le", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_le", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_ge", test: 0, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,

  // mod: "aot", func: "f32_ge", test: 1, params: 2, results: 1
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_F32,
  PWASM_VALUE_TYPE_I32,
};

typedef struct {
  const char * const mod;
  const char * const func;
  const bool fails;
  const pwasm_slice_t params;
  const pwasm_slice_t results;
} test_call_t;

static const test_call_t
TEST_CALLS[] = {{
  .mod      = "aot",
  .func     = "add_i32s",
  .results  = { 0, 1 },
}, {
  .mod      = "aot",
  .func     = "trap",
  .fails    = true,
}, {
  .mod      = "aot",
  .func     = "if_else_true",
  .results  = { 1, 1 },
}, {
  .mod      = "aot",
  .func     = "if_else_false",
  .results  = { 2, 1 },
}, {
  .mod      = "aot",
  .func     = "if_true",
  .results  = { 3, 1 },
}, {
  .mod      = "aot",
  .func     = "if_false",
  .results  = { 4, 1 },
}, {
  .mod      = "aot",
  .func     = "br_outer",
  .results  = { 5, 1 },
}, {
  .mod      = "aot",
  .func     = "br_inner",
  .results  = { 6, 1 },
}, {
  .mod      = "aot",
  .func     = "sub",
  .params  = { 7, 2 },
  .results = { 9, 1 },
}, {
  .mod      = "aot",
  .func     = "is_99",
  .params  = { 10, 1 },
  .results = { 11, 1 },
}, {
  .mod      = "aot",
  .func     = "is_99",
  .params  = { 12, 1 },
  .results = { 13, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_eqz",
  .params  = { 14, 1 },
  .results = { 15, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_eqz",
  .params  = { 16, 1 },
  .results = { 17, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_eq",
  .params  = { 18, 2 },
  .results = { 20, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_eq",
  .params  = { 21, 2 },
  .results = { 23, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ne",
  .params  = { 24, 2 },
  .results = { 26, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ne",
  .params  = { 27, 2 },
  .results = { 29, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_lt_s",
  .params  = { 30, 2 },
  .results = { 32, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_lt_s",
  .params  = { 33, 2 },
  .results = { 35, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_lt_s",
  .params  = { 36, 2 },
  .results = { 38, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_lt_u",
  .params  = { 39, 2 },
  .results = { 41, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_lt_u",
  .params  = { 42, 2 },
  .results = { 44, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_lt_u",
  .params  = { 45, 2 },
  .results = { 47, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_gt_s",
  .params  = { 48, 2 },
  .results = { 50, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_gt_s",
  .params  = { 51, 2 },
  .results = { 53, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_gt_s",
  .params  = { 54, 2 },
  .results = { 56, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_gt_u",
  .params  = { 57, 2 },
  .results = { 59, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_gt_u",
  .params  = { 60, 2 },
  .results = { 62, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_gt_u",
  .params  = { 63, 2 },
  .results = { 65, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_le_s",
  .params  = { 66, 2 },
  .results = { 68, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_le_s",
  .params  = { 69, 2 },
  .results = { 71, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_le_s",
  .params  = { 72, 2 },
  .results = { 74, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_le_u",
  .params  = { 75, 2 },
  .results = { 77, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_le_u",
  .params  = { 78, 2 },
  .results = { 80, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_le_u",
  .params  = { 81, 2 },
  .results = { 83, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ge_s",
  .params  = { 84, 2 },
  .results = { 86, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ge_s",
  .params  = { 87, 2 },
  .results = { 89, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ge_s",
  .params  = { 90, 2 },
  .results = { 92, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ge_u",
  .params  = { 93, 2 },
  .results = { 95, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ge_u",
  .params  = { 96, 2 },
  .results = { 98, 1 },
}, {
  .mod      = "aot",
  .func     = "i32_ge_u",
  .params  = { 99, 2 },
  .results = { 101, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_eqz",
  .params  = { 102, 1 },
  .results = { 103, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_eqz",
  .params  = { 104, 1 },
  .results = { 105, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_eq",
  .params  = { 106, 2 },
  .results = { 108, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_eq",
  .params  = { 109, 2 },
  .results = { 111, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ne",
  .params  = { 112, 2 },
  .results = { 114, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ne",
  .params  = { 115, 2 },
  .results = { 117, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_lt_s",
  .params  = { 118, 2 },
  .results = { 120, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_lt_s",
  .params  = { 121, 2 },
  .results = { 123, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_lt_s",
  .params  = { 124, 2 },
  .results = { 126, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_lt_u",
  .params  = { 127, 2 },
  .results = { 129, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_lt_u",
  .params  = { 130, 2 },
  .results = { 132, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_lt_u",
  .params  = { 133, 2 },
  .results = { 135, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_gt_s",
  .params  = { 136, 2 },
  .results = { 138, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_gt_s",
  .params  = { 139, 2 },
  .results = { 141, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_gt_s",
  .params  = { 142, 2 },
  .results = { 144, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_gt_u",
  .params  = { 145, 2 },
  .results = { 147, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_gt_u",
  .params  = { 148, 2 },
  .results = { 150, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_gt_u",
  .params  = { 151, 2 },
  .results = { 153, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_le_s",
  .params  = { 154, 2 },
  .results = { 156, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_le_s",
  .params  = { 157, 2 },
  .results = { 159, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_le_s",
  .params  = { 160, 2 },
  .results = { 162, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_le_u",
  .params  = { 163, 2 },
  .results = { 165, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_le_u",
  .params  = { 166, 2 },
  .results = { 168, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_le_u",
  .params  = { 169, 2 },
  .results = { 171, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ge_s",
  .params  = { 172, 2 },
  .results = { 174, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ge_s",
  .params  = { 175, 2 },
  .results = { 177, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ge_s",
  .params  = { 178, 2 },
  .results = { 180, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ge_u",
  .params  = { 181, 2 },
  .results = { 183, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ge_u",
  .params  = { 184, 2 },
  .results = { 186, 1 },
}, {
  .mod      = "aot",
  .func     = "i64_ge_u",
  .params  = { 187, 2 },
  .results = { 189, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_eq",
  .params  = { 190, 2 },
  .results = { 192, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_eq",
  .params  = { 193, 2 },
  .results = { 195, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_ne",
  .params  = { 196, 2 },
  .results = { 198, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_ne",
  .params  = { 199, 2 },
  .results = { 201, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_lt",
  .params  = { 202, 2 },
  .results = { 204, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_lt",
  .params  = { 205, 2 },
  .results = { 207, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_gt",
  .params  = { 208, 2 },
  .results = { 210, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_gt",
  .params  = { 211, 2 },
  .results = { 213, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_le",
  .params  = { 214, 2 },
  .results = { 216, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_le",
  .params  = { 217, 2 },
  .results = { 219, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_ge",
  .params  = { 220, 2 },
  .results = { 222, 1 },
}, {
  .mod      = "aot",
  .func     = "f32_ge",
  .params  = { 223, 2 },
  .results = { 225, 1 },
}};

static size_t get_test_name(
  char * const dst,
  const test_call_t test
) {
  const size_t mod_len = strlen(test.mod);
  const size_t func_len = strlen(test.func);
  size_t ofs = 0;

  memcpy(dst, test.mod, mod_len);
  ofs += mod_len;

  dst[ofs] = '.';
  ofs += 1;

  memcpy(dst + ofs, test.func, func_len);
  ofs += func_len;

  dst[ofs] = '(';
  ofs += 1;

  for (size_t i = 0; i < test.params.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.params.ofs + i];

    switch (type) {
    case PWASM_VALUE_TYPE_I32:
      ofs += sprintf(dst + ofs, "%s%u", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].i32);
      break;
    case PWASM_VALUE_TYPE_I64:
      ofs += sprintf(dst + ofs, "%s%lu", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].i64);
      break;
    case PWASM_VALUE_TYPE_F32:
      ofs += sprintf(dst + ofs, "%s%f", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].f32);
      break;
    case PWASM_VALUE_TYPE_F64:
      ofs += sprintf(dst + ofs, "%s%f", ((i > 0) ? ", " : ""), TEST_VALS[test.params.ofs + i].f64);
      break;
    default:
      // never reached
      errx(EXIT_FAILURE, "unknown value type: %u", type);
    }
  }

  memcpy(dst + ofs, "), [", 4);
  ofs += 4;

  for (size_t i = 0; i < test.params.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.params.ofs + i];
    const char * const name = pwasm_value_type_get_name(type);
    const size_t name_len = strlen(name);

    if (i > 0) {
      dst[ofs] = ',';
      dst[ofs + 1] = ' ';
      ofs += 2;
    }

    memcpy(dst + ofs, name, name_len);
    ofs += name_len;
  }

  memcpy(dst + ofs, "] -> [", 6);
  ofs += 6;

  for (size_t i = 0; i < test.results.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.results.ofs + i];
    const char * const name = pwasm_value_type_get_name(type);
    const size_t name_len = strlen(name);

    if (i > 0) {
      dst[ofs] = ',';
      dst[ofs + 1] = ' ';
      ofs += 2;
    }

    memcpy(dst + ofs, name, name_len);
    ofs += name_len;
  }

  dst[ofs] = ']';
  ofs += 1;

  // terminate
  dst[ofs] = '\0';

  // return name length, excluding null byte
  return ofs;
}

static void check_results(
  cli_test_ctx_t * const test_ctx,
  const cli_test_t * const cli_test,
  const test_call_t test,
  const char * const test_name,
  const pwasm_stack_t * const stack
) {
  char buf[1024];
  char name_buf[512];

  for (size_t i = 0; i < test.results.len; i++) {
    const pwasm_value_type_t type = TEST_TYPES[test.results.ofs + i];
    const pwasm_val_t got_val = stack->ptr[i];
    const pwasm_val_t exp_val = TEST_VALS[test.results.ofs + i];

    snprintf(name_buf, sizeof(name_buf), "%s: check results[%zu]", test_name, i);

    switch (type) {
    case PWASM_VALUE_TYPE_I32:
      if (got_val.i32 == exp_val.i32) {
        // build pass text
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // build fail text
        snprintf(buf, sizeof(buf), "%s failed: got 0x%08x, expected 0x%08x", name_buf, got_val.i32, exp_val.i32);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    case PWASM_VALUE_TYPE_I64:
      if (got_val.i64 == exp_val.i64) {
        // build pass text
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // build fail text
        snprintf(buf, sizeof(buf), "%s failed: got 0x%016lx, expected 0x%016lx", name_buf, got_val.i64, exp_val.i64);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    case PWASM_VALUE_TYPE_F32:
      if (NEARLY_EQUAL(got_val.f32, exp_val.f32)) {
        // pass assertion
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // fail assertion
        snprintf(buf, sizeof(buf), "%s failed: got %f, expected %f", name_buf, got_val.f32, exp_val.f32);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    case PWASM_VALUE_TYPE_F64:
      if (NEARLY_EQUAL(got_val.f64, exp_val.f64)) {
        // pass assertion
        cli_test_pass(test_ctx, cli_test, name_buf);
      } else {
        // fail assertion
        snprintf(buf, sizeof(buf), "%s failed: got %f, expected %f", name_buf, got_val.f64, exp_val.f64);
        cli_test_fail(test_ctx, cli_test, buf);
      }

      break;
    default:
      // never reached
      snprintf(buf, sizeof(buf), "unknown value type: %u", type);
      cli_test_error(test_ctx, buf);
      return;
    }
  }
}

void test_compile(
  cli_test_ctx_t * const test_ctx,
  const cli_test_t * const cli_test
) {
  // create a memory context
  pwasm_mem_ctx_t mem_ctx = pwasm_mem_ctx_init_defaults(NULL);

  // set up stack
  pwasm_val_t stack_vals[MAX_STACK_DEPTH];
  pwasm_stack_t stack = {
    .ptr = stack_vals,
    .len = MAX_STACK_DEPTH,
  };

  // get interpreter callbacks
  pwasm_env_cbs_t cbs;
  pwasm_aot_jit_get_cbs(&cbs, pwasm_compile);

  // create environment, check for error
  pwasm_env_t env;
  if (!pwasm_env_init(&env, &mem_ctx, &cbs, &stack, NULL)) {
    cli_test_error(test_ctx, "pwasm_env_init() failed");
    return;
  }

  // build buffer
  const pwasm_buf_t buf = { AOT_WASM, sizeof(AOT_WASM) };

  // parse mod, check for error
  pwasm_mod_t mod;
  if (!pwasm_mod_init(&mem_ctx, &mod, buf)) {
    cli_test_error(test_ctx, "pwasm_mod_init() failed");
    return;
  }

  // add mod to env, check for error
  if (!pwasm_env_add_mod(&env, "aot", &mod)) {
    cli_test_error(test_ctx, "pwasm_env_add_mod() failed");
    return;
  }

  for (size_t i = 0; i < LEN(TEST_CALLS); i++) {
    const test_call_t test = TEST_CALLS[i];

    // populate stack
    stack.pos = test.params.len;
    if (test.params.len > 0) {
      const size_t num_bytes =  test.params.len * sizeof(pwasm_val_t);
      memcpy(stack.ptr, TEST_VALS + test.params.ofs, num_bytes);
    }

    char name_buf[512];
    char buf[1024];
    get_test_name(name_buf, test);

    // call function, check result
    const bool call_ok = (pwasm_call(&env, test.mod, test.func) != test.fails);
    if (call_ok) {
      snprintf(buf, sizeof(buf), "%s: call passed", name_buf);
      cli_test_pass(test_ctx, cli_test, buf);
    } else {
      snprintf(buf, sizeof(buf), "%s: call failed", name_buf);
      cli_test_fail(test_ctx, cli_test, buf);
    }

    // check stack size
    if (call_ok && !test.fails) {
      if (stack.pos == test.results.len) {
        snprintf(buf, sizeof(buf), "%s: stack size == %zu", name_buf, stack.pos);
        cli_test_pass(test_ctx, cli_test, buf);
      } else {
        snprintf(buf, sizeof(buf), "%s: stack size: got %zu, expected %zu", name_buf, stack.pos, test.results.len);
        cli_test_fail(test_ctx, cli_test, buf);
      }
    } else if (call_ok && test.fails) {
      snprintf(buf, sizeof(buf), "%s: stack size: n/a", name_buf);
      cli_test_pass(test_ctx, cli_test, buf);
    } else {
      snprintf(buf, sizeof(buf), "%s: stack size: call failed", name_buf);
      cli_test_fail(test_ctx, cli_test, buf);
    }

    if (call_ok && !test.fails) {
      check_results(test_ctx, cli_test, test, name_buf, &stack);
    }
  }
}
