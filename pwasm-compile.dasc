/**
 * pwasm_compile(): JIT compiler for PWASM module functions implemented
 * via DynASM.
 */

#define _GNU_SOURCE
#include <stdbool.h> // bool
#include <stdio.h> // snprintf()
#include <sys/mman.h> // mprotect
#include "pwasm-compile.h"
#include "pwasm-dump.h"
#include <dlfcn.h> // dlsym()
#include <dynasm/dasm_proto.h>

|.arch x64
|.actionlist actions
|.globals lbl_
|.externnames externs

#undef DASM_EXTERN
#define DASM_EXTERN(ctx, addr, idx, type) (\
  (type) ? \
  (uintptr_t) ((unsigned char*) dlsym(RTLD_DEFAULT, externs[idx]) - (addr) - 4) : \
  (uintptr_t) dlsym(RTLD_DEFAULT, externs[idx]) \
)

#include <dynasm/dasm_x86.h>

#ifdef PWASM_DEBUG
#define D(fmt, ...) fprintf( \
  stderr, \
  "D %s:%d %s(): " fmt "\n", \
  __FILE__, __LINE__, __func__, __VA_ARGS__ \
)
#else
#define D(fmt, ...)
#endif /* PWASM_DEBUG */

// function args
// sysv amd64 calling convention
// (https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions)
|.define r_arg0, rdi
|.define r_arg1, rsi
|.define r_arg2, rdx
|.define r_arg3, rcx

// pointer to base and tail of stack
|.define r_env, r12
|.define r_base, r13
|.define r_stack, r14

// TODO
|.macro save_regs
  | sub rsp, 8
  | push r12
  | push r13
  | push r14
|.endmacro

// TODO
|.macro restore_regs
  | pop r14
  | pop r13
  | pop r12
  | add rsp, 8
|.endmacro

| .macro callp, addr
  | mov64 rax, (uintptr_t) addr
  | call rax
| .endmacro

|.macro stack_inc
  | add r_stack, sizeof(pwasm_val_t)
|.endmacro

|.macro stack_dec
  | sub r_stack, sizeof(pwasm_val_t)
|.endmacro

|.macro stack_decn, num
  | sub r_stack, (num * sizeof(pwasm_val_t))
|.endmacro

|.macro i32_testop_init
  | mov eax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i32_testop_fini
  | mov eax, 0
  | sete al
  | mov [r_stack - sizeof(pwasm_val_t)], eax
|.endmacro

|.macro i32_unop_init
  | mov eax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i32_unop_fini
  | mov [r_stack - sizeof(pwasm_val_t)], eax
|.endmacro

|.macro i32_relop_init
  | mov eax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov ebx, [r_stack - sizeof(pwasm_val_t)]
  | cmp eax, ebx
  | mov eax, 0
|.endmacro

|.macro i32_relop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
  | stack_dec
|.endmacro

|.macro i32_binop_init
  | mov eax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov ebx, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i32_binop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
  | stack_dec
|.endmacro

|.macro i64_testop_init
  | mov rax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i64_testop_fini
  | mov eax, 0
  | sete al
  | mov [r_stack - sizeof(pwasm_val_t)], eax
|.endmacro

|.macro i64_unop_init
  | mov rax, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i64_unop_fini
  | mov [r_stack - sizeof(pwasm_val_t)], rax
|.endmacro

|.macro i64_relop_init
  | mov rax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov rbx, [r_stack - sizeof(pwasm_val_t)]
  | cmp rax, rbx
  | mov eax, 0
|.endmacro

|.macro i64_relop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
  | stack_dec
|.endmacro

|.macro i64_binop_init
  | mov rax, [r_stack - 2 * sizeof(pwasm_val_t)]
  | mov rbx, [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro i64_binop_fini
  | mov [r_stack - 2 * sizeof(pwasm_val_t)], rax
  | stack_dec
|.endmacro

|.macro f32_relop_init
  | movd xmm0, dword [r_stack - 2 * sizeof(pwasm_val_t)]
  | movd xmm1, dword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f32_relop_fini
  | psrld xmm0, 31
  | movd dword [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

|.macro f64_relop_init
  | movq xmm0, qword [r_stack - 2 * sizeof(pwasm_val_t)]
  | movq xmm1, qword [r_stack - sizeof(pwasm_val_t)]
|.endmacro

|.macro f64_relop_fini
  | psrld xmm0, 31
  | movd dword [r_stack - 2 * sizeof(pwasm_val_t)], xmm0
  | stack_dec
|.endmacro

/**
 * Call error handler.
 */
static void
fail(
  pwasm_env_t * const env,
  const char * const text
) {
  D("%s", text);
  pwasm_fail(env->mem_ctx, text);
}

static void
test_func(
  const char * const text
) {
  D("text = %s", text);
}

//
// control stack: used by compiler to manage control frames
//

// control stack entry types
#define CTRL_TYPES \
  CTRL_TYPE(BLOCK) \
  CTRL_TYPE(LOOP) \
  CTRL_TYPE(IF) \
  CTRL_TYPE(ELSE)

// control stack entry types
typedef enum {
#define CTRL_TYPE(a) CTRL_ ## a,
CTRL_TYPES
#undef CTRL_TYPE
  CTRL_LAST,
} pwasm_ctrl_stack_entry_type_t;

// control stack entry
typedef struct {
  pwasm_ctrl_stack_entry_type_t type; // entry type
  int32_t block_type; // block type
  size_t label;
} pwasm_ctrl_stack_entry_t;

// control stack
typedef struct {
  // vector of entries
  pwasm_vec_t stack;
} pwasm_ctrl_stack_t;

/**
 * Initialize control stack.
 *
 * Returns `true` on success or `false` on error.
 */
static bool
pwasm_ctrl_stack_init(
  pwasm_ctrl_stack_t * const stack,
  pwasm_mem_ctx_t * const mem_ctx
) {
  const size_t stride = sizeof(pwasm_ctrl_stack_entry_t);
  return pwasm_vec_init(mem_ctx, &(stack->stack), stride);
}

/**
 * Finalize control stack.
 */
static void
pwasm_ctrl_stack_fini(
  pwasm_ctrl_stack_t * const stack
) {
  pwasm_vec_fini(&(stack->stack));
}

#if 0
static size_t
pwasm_ctrl_stack_get_size(
  const pwasm_ctrl_stack_t * const stack
) {
  return pwasm_vec_get_size(&(stack->stack));
}
#endif /* 0 */

static const void *
pwasm_ctrl_stack_peek_tail(
  const pwasm_ctrl_stack_t * const stack,
  const size_t ofs
) {
  return pwasm_vec_peek_tail(&(stack->stack), ofs);
}

/**
 * Remove tail entry from control stack.
 *
 * Returns `false` if an error occurred.
 */
static bool
pwasm_ctrl_stack_pop(
  pwasm_ctrl_stack_t * const stack,
  pwasm_ctrl_stack_entry_t * const dst
) {
  // pop final entry, return result
  return pwasm_vec_pop(&(stack->stack), dst);
}

/**
 * Append entry to tail of control stack.
 *
 * Returns `false` if an error occurred.
 */
static bool
pwasm_ctrl_stack_push(
  pwasm_ctrl_stack_t * const stack,
  const pwasm_ctrl_stack_entry_t entry
) {
  return pwasm_vec_push(&(stack->stack), 1, &entry, NULL);
}

/**
 * Compile the given module function and then populate the given
 * destination buffer with the length of the generated code and a
 * pointer to the start of the function.
 *
 * Returns `true` on success, or `false` if an error occurred.
 */
bool
pwasm_compile(
  pwasm_buf_t * const dst,
  pwasm_env_t *env,
  const uint32_t mod_id,
  const pwasm_mod_t *mod,
  const size_t func_ofs
) {
  const pwasm_type_t type = mod->types[mod->funcs[func_ofs]];
  const pwasm_func_t func = mod->codes[func_ofs];
  const pwasm_inst_t * const insts = mod->insts + func.expr.ofs;

  // init control stack
  size_t ctrl_depth = 0;
  pwasm_ctrl_stack_t ctrl_stack;
  if (!pwasm_ctrl_stack_init(&ctrl_stack, env->mem_ctx)) {
    fail(env, "ctrl_stack_init failed");
    return false;
  }

  // init jit
  void *labels[lbl__MAX];
  dasm_State *dasm;
  D("dasm_init(%u)", 1);
  dasm_init(&dasm, 1);
  dasm_setupglobal(&dasm, labels, lbl__MAX);
  dasm_setup(&dasm, actions);
  dasm_growpc(&dasm, 100); // FIXME

  dasm_State** Dst = &dasm;
  | ->enter:
  // get env pointer
  | mov r_env, r_arg0

  // get stack pointer from env
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | mov r_stack, [rax + offsetof(pwasm_stack_t, ptr)]

  // get stack offset
  | imul rbx, [rax + offsetof(pwasm_stack_t, pos)], sizeof(pwasm_val_t)

  // increment stack pointer
  | add r_stack, rbx
  | mov r_base, r_stack

  size_t max_label = 0;
  for (size_t i = 0; i < func.expr.len; i++) {
    const pwasm_inst_t in = insts[i];
    switch (in.op) {
    case PWASM_OP_I32_CONST:
      D("0x%02X %s (0x%08x)", in.op, pwasm_op_get_name(in.op), in.v_i32);
      break;
    default:
      D("0x%02X %s", in.op, pwasm_op_get_name(in.op));
    }

    switch (in.op) {
    case PWASM_OP_UNREACHABLE:
      {
        // log error message (FIXME)
        // const char * const err = "unreachable";
        // | mov r_arg0, env
        // | mov r_arg1, err
        // | call aword fail

        // return failure
        | jmp ->exit_failure
      }
      break;
    case PWASM_OP_NOP:
      | nop
      break;
    case PWASM_OP_BLOCK:
      {
        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "block: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // decriment stack (block parameters)
          | stack_decn num_params
        }

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_BLOCK,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "block: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label++;
        dasm_growpc(&dasm, max_label);
      }

      break;
    case PWASM_OP_LOOP:
      {
        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "loop: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // decriment stack (block parameters)
          | stack_decn num_params
        }

        // emit label
        |=>max_label:

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_LOOP,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "loop: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label++;
        dasm_growpc(&dasm, max_label);
      }

      break;
    case PWASM_OP_IF:
      {
        // emit condition pop
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | stack_dec

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_IF,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "if: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label += 2;
        dasm_growpc(&dasm, max_label);

        // emit compare
        | cmp eax, 0
        | je =>entry.label

        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "if: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // emit stack pop (block parameters)
          D("num_params = %zu", num_params);
          // FIXME
          // | stack_decn num_params
        }
      }

      break;
    case PWASM_OP_ELSE:
      {
        // pop if entry, check for error
        pwasm_ctrl_stack_entry_t if_entry;
        if (!pwasm_ctrl_stack_pop(&ctrl_stack, &if_entry)) {
          fail(env, "else: ctrl_stack_pop failed");
          return false;
        }

        // decriment control depth
        // disabled, redundant
        // ctrl_depth--;

        // emit unconditional jump to end
        | jmp =>(if_entry.label + 1)
        // emit else label
        | =>(if_entry.label):

        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, if_entry.block_type, &num_params)) {
          // log error, return failure
          fail(env, "if: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // emit stack pop (block parameters)
          D("num_params = %zu", num_params);
          | stack_decn num_params
        }

        // create control stack entry
        const pwasm_ctrl_stack_entry_t else_entry = {
          .type       = CTRL_ELSE,
          .block_type = if_entry.block_type,
          .label      = if_entry.label + 1,
        };

        // push else entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, else_entry)) {
          fail(env, "else: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        // disabled, redundant
        // ctrl_depth++;
      }

      break;
    case PWASM_OP_END:
      if (ctrl_depth > 0) {
        // pop control stack, check for error
        pwasm_ctrl_stack_entry_t tail;
        if (!pwasm_ctrl_stack_pop(&ctrl_stack, &tail)) {
          fail(env, "ctrl_stack_pop failed");
          return false;
        }

        // decriment depth
        ctrl_depth--;

        switch (tail.type) {
        case CTRL_IF:
          // emit tail labels
          // FIXME: is this right?
          | =>(tail.label):
          | =>(tail.label + 1):
          break;
        case CTRL_ELSE:
        case CTRL_BLOCK:
          // emit tail label
          | =>(tail.label):
          break;
        case CTRL_LOOP:
          // do nothing
          break;
        default:
          {
            // log error
            char buf[512];
            snprintf(buf, sizeof(buf), "unknown ctrl stack entry type: %u", tail.type);
            fail(env, buf);

            // return failure
            return false;
          }
        }

        // get block type result count, check for error
        size_t num_results;
        if (!pwasm_block_type_results_get_size(mod, tail.block_type, &num_results)) {
          // log error, return failure
          fail(env, "end: get block num_results failed");
          return false;
        }

        // pop results
        // TODO
//         for (size_t j = 0; j < num_results; j++) {
//           // calculate stack source and destination offsets
//           const size_t src_ofs = stack->pos - 1 - (num_results - 1 - j);
//           const size_t dst_ofs = ctrl_tail.depth + j;
//           stack->ptr[dst_ofs] = stack->ptr[src_ofs];
//         }
      } else {
        // emit exit success
        | jmp ->exit_success
      }

      break;
    case PWASM_OP_BR:
      if ((ctrl_depth > 0) && (ctrl_depth - in.v_index) > 0) {
        // get control stack tail, check for error
        const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, in.v_index);
        if (!tail) {
          fail(env, "br: ctrl_stack_peek_tail failed");
          return false;
        }

        // get destination label
        const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

        // emit jump to label
        | jmp =>label
      } else {
        // emit exit success
        | jmp ->exit_success
      }

      break;
    case PWASM_OP_BR_IF:
      // emit compare
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | stack_dec
      | cmp eax, 0

      if ((ctrl_depth > 0) && (ctrl_depth - in.v_index) > 0) {
        // get control stack tail, check for error
        const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, in.v_index);
        if (!tail) {
          fail(env, "br: ctrl_stack_peek_tail failed");
          return false;
        }

        // get destination label
        const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

        // emit jump to label
        | je =>label
      } else {
        // emit exit success
        | je ->exit_success
      }

      break;
    case PWASM_OP_BR_TABLE:
      {
        // get branch labels
        const pwasm_slice_t labels = in.v_br_table;

        // pop index
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | stack_dec

        // emit labels
        // FIXME: this could be optimized into a jump table
        for (size_t j = 0; j < labels.len - 1; j++) {
          const uint32_t ofs = mod->u32s[labels.ofs + j];

          if ((ctrl_depth > 0) && (ctrl_depth - ofs) > 0) {
            const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, ofs);
            if (!tail) {
              fail(env, "br_table: ctrl_stack_peek_tail failed");
              return false;
            }

            // get destination label
            const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

            // emit conditional jump
            | cmp eax, j
            | je =>label
          } else {
            // emit exit success
            | cmp eax, j
            | je ->exit_success
          }
        }

        // emit unconditional jump to default label
        {
          // get offset of last branch target
          const uint32_t ofs = mod->u32s[labels.ofs + labels.len - 1];

          if ((ctrl_depth > 0) && (ctrl_depth - ofs) > 0) {
            const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, ofs);
            if (!tail) {
              fail(env, "br_table: ctrl_stack_peek_tail failed");
              return false;
            }

            // get destination label
            const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

            // emit unconditional jump to default label
            | jmp =>label
          } else {
            // emit unconditional jump to exit_success
            | jmp ->exit_success
          }
        }
      }

      break;
    case PWASM_OP_RETURN:
      // emit unconditional jump to exit_success
      | jmp ->exit_success

      break;
    case PWASM_OP_CALL:
      // TODO: emit store stack position, push registers
      | mov r_arg0, env
      | mov r_arg1, mod
      | mov r_arg2, in.v_index
      // TODO: | call aword pwasm_aot_jit_call_func
      | cmp eax, 0
      | je ->exit_failure
      // TODO: pop registers, restore stack position

      break;
    // TODO: case PWASM_OP_CALL_INDIRECT:
    case PWASM_OP_DROP:
      | stack_dec

      break;
    case PWASM_OP_SELECT:
      // pop value, compare to zero
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | cmp eax, 0

      // get left value (FIXME: use xmm?)
      | cmovnz rax, [r_stack - 3 * sizeof(pwasm_val_t)]
      | cmovnz rbx, [r_stack - 3 * sizeof(pwasm_val_t) + sizeof(uint64_t)]

      // get right value (FIXME: use xmm?)
      | cmovz rax, [r_stack - 2 * sizeof(pwasm_val_t)]
      | cmovz rbx, [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)]

      // store result
      | mov [r_stack - 3 * sizeof(pwasm_val_t)], rax
      | mov [r_stack - 3 * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx

      // decriment stack
      | stack_decn 2

      break;
    case PWASM_OP_LOCAL_GET:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_base - ofs * sizeof(pwasm_val_t)]
        | mov rbx, [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_stack], rax
        | mov [r_stack + sizeof(uint64_t)], rbx
        | stack_inc
      }

      break;
    case PWASM_OP_LOCAL_SET:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_base - ofs * sizeof(pwasm_val_t)], rax
        | mov [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
        | stack_dec
      }

      break;
    case PWASM_OP_LOCAL_TEE:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_base - ofs * sizeof(pwasm_val_t)], rax
        | mov [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
      }

      break;
    case PWASM_OP_GLOBAL_GET:
      {
        // get global index
        const uint32_t global_id = env->cbs->get_global_index(env, mod_id, in.v_index);

        union {
          void (*ptr_func)();
          void *ptr_void;
        } tmp = { .ptr_func = test_func };

        D("global_id = %u, test_func = 0x%p", global_id, tmp.ptr_void);

        // DEBUG: emit fail
        // FIXME: "call extern" is not documented on the dynasm page
        // | call aword &test_func
        // | mov rax, 0

        // emit call
        | save_regs
        | mov r_arg0, r_env
        | mov r_arg1, global_id
        | mov r_arg2, r_stack
        // | mov rax, aword pwasm_env_get_global
        | call extern pwasm_env_get_global
        | restore_regs

        // check for error
        | cmp eax, 0
        | je ->exit_failure

        // increment stack
        | stack_inc
      }

      break;
    case PWASM_OP_GLOBAL_SET:
      {
        // get global index
        const uint32_t global_id = env->cbs->get_global_index(env, mod_id, in.v_index);
        D("global_id = %u", global_id);

        // push value to stack
        | push qword [r_stack - sizeof(pwasm_val_t)]
        | push qword [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]

        // emit call
        | mov r_arg0, r_env
        | mov r_arg1, global_id
        | mov rax, aword pwasm_env_set_global
        | call rax

        // check for error
        | cmp eax, 0
        | je ->exit_failure

        // pop value from stack
        | add rsp, 32

        // increment stack
        | stack_inc
      }

      break;
    // TODO: load, store, mem.grow, mem.size
    // (need call to work before i can implement these)
    case PWASM_OP_I32_CONST:
      | mov dword [r_stack], in.v_i32
      | stack_inc

      break;
    case PWASM_OP_I64_CONST:
      | mov qword [r_stack], in.v_i64
      | stack_inc

      break;
    case PWASM_OP_F32_CONST:
      | mov qword [r_stack], in.v_f32
      | stack_inc

      break;
    case PWASM_OP_F64_CONST:
      | mov qword [r_stack], in.v_f64
      | stack_inc

      break;
    case PWASM_OP_I32_EQZ:
      | i32_testop_init
      | cmp eax, 0
      | i32_testop_fini

      break;
    case PWASM_OP_I32_EQ:
      | i32_relop_init
      | sete al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_NE:
      | i32_relop_init
      | setne al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LT_S:
      | i32_relop_init
      | setl al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LT_U:
      | i32_relop_init
      | setb al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GT_S:
      | i32_relop_init
      | setg al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GT_U:
      | i32_relop_init
      | seta al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LE_S:
      | i32_relop_init
      | setle al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_LE_U:
      | i32_relop_init
      | setbe al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GE_S:
      | i32_relop_init
      | setge al
      | i32_relop_fini

      break;
    case PWASM_OP_I32_GE_U:
      | i32_relop_init
      | setae al
      | i32_relop_fini

      break;
    case PWASM_OP_I64_EQZ:
      | i64_testop_init
      | cmp rax, 0
      | i64_testop_fini

      break;
    case PWASM_OP_I64_EQ:
      | i64_relop_init
      | sete al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_NE:
      | i64_relop_init
      | setne al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LT_S:
      | i64_relop_init
      | setl al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LT_U:
      | i64_relop_init
      | setb al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GT_S:
      | i64_relop_init
      | setg al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GT_U:
      | i64_relop_init
      | seta al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LE_S:
      | i64_relop_init
      | setle al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_LE_U:
      | i64_relop_init
      | setbe al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GE_S:
      | i64_relop_init
      | setge al
      | i64_relop_fini

      break;
    case PWASM_OP_I64_GE_U:
      | i64_relop_init
      | setae al
      | i64_relop_fini

      break;
    case PWASM_OP_F32_EQ:
      | f32_relop_init
      | cmpss xmm0, xmm1, 0
      | f32_relop_fini

      break;
    case PWASM_OP_F32_NE:
      | f32_relop_init
      | cmpss xmm0, xmm1, 4
      | f32_relop_fini

      break;
    case PWASM_OP_F32_LT:
      | f32_relop_init
      | cmpss xmm0, xmm1, 1
      | f32_relop_fini

      break;
    case PWASM_OP_F32_GT:
      | f32_relop_init
      | cmpss xmm0, xmm1, 6
      | f32_relop_fini

      break;
    case PWASM_OP_F32_LE:
      | f32_relop_init
      | cmpss xmm0, xmm1, 2
      | f32_relop_fini

      break;
    case PWASM_OP_F32_GE:
      | f32_relop_init
      | cmpss xmm0, xmm1, 5
      | f32_relop_fini

      break;
    case PWASM_OP_F64_EQ:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 0
      | f64_relop_fini

      break;
    case PWASM_OP_F64_NE:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 4
      | f64_relop_fini

      break;
    case PWASM_OP_F64_LT:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 1
      | f64_relop_fini

      break;
    case PWASM_OP_F64_GT:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 6
      | f64_relop_fini

      break;
    case PWASM_OP_F64_LE:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 2
      | f64_relop_fini

      break;
    case PWASM_OP_F64_GE:
      | f64_relop_init
      | cmpsd xmm0, xmm1, 5
      | f64_relop_fini

      break;
    case PWASM_OP_I32_CLZ:
      // FIXME: use lzcnt instead of bsr?
      | i32_unop_init
      | bsr ebx, eax
      | mov eax, 31
      | sub eax, ebx
      | i32_unop_fini

      break;
    case PWASM_OP_I32_CTZ:
      // FIXME: use tzcnt instead of bsf?
      | i32_unop_init
      | bsf eax, eax
      | i32_unop_fini

      break;
    case PWASM_OP_I32_POPCNT:
      | i32_unop_init
      | popcnt eax, eax
      | i32_unop_fini

      break;
    case PWASM_OP_I32_ADD:
      | i32_binop_init
      | add eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SUB:
      | i32_binop_init
      | sub eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_MUL:
      | i32_binop_init
      | mul ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_DIV_S:
      | i32_binop_init
      | cdq           // sign-extend eax into edx
      | idiv ebx      // signed divide
      | i32_binop_fini

      break;
    case PWASM_OP_I32_DIV_U:
      | i32_binop_init
      | mov edx, 0    // zero-extend into edx
      | div ebx       // unsigned divide
      | i32_binop_fini

      break;
    case PWASM_OP_I32_REM_S:
      | i32_binop_init
      | cdq           // sign-extend eax into edx
      | idiv ebx      // signed divide
      | mov eax, edx  // save remainder
      | i32_binop_fini

      break;
    case PWASM_OP_I32_REM_U:
      | i32_binop_init
      | mov edx, 0    // zero edx
      | div ebx       // unsigned divide
      | mov eax, edx  // save remainder
      | i32_binop_fini

      break;
    case PWASM_OP_I32_AND:
      | i32_binop_init
      | and eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_OR:
      | i32_binop_init
      | or eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_XOR:
      | i32_binop_init
      | xor eax, ebx
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SHL:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | shl eax, cl   // shift left
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SHR_S:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | sar eax, cl   // shift right (arithmetic)
      | i32_binop_fini

      break;
    case PWASM_OP_I32_SHR_U:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | shr eax, cl   // shift right (logical)
      | i32_binop_fini

      break;
    case PWASM_OP_I32_ROTL:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | rol eax, cl   // rotate left
      | i32_binop_fini

      break;
    case PWASM_OP_I32_ROTR:
      | i32_binop_init
      | mov cl, bl    // move shift to cl
      | ror eax, cl   // rotate right
      | i32_binop_fini

      break;
    case PWASM_OP_I64_CLZ:
      // FIXME: use lzcnt instead of bsr?
      | i64_unop_init
      | bsr rbx, rax
      | mov eax, 63
      | sub eax, ebx
      | i64_unop_fini

      break;
    case PWASM_OP_I64_CTZ:
      // FIXME: use tzcnt instead of bsf?
      | i64_unop_init
      | bsf rax, rax
      | i64_unop_fini

      break;
    case PWASM_OP_I64_POPCNT:
      | i64_unop_init
      | popcnt rax, rax
      | i64_unop_fini

      break;
    case PWASM_OP_I64_ADD:
      | i64_binop_init
      | add rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SUB:
      | i64_binop_init
      | sub rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_MUL:
      | i64_binop_init
      | mul rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_DIV_S:
      | i64_binop_init
      | cqo           // sign-extend eax into edx
      | idiv rbx      // signed divide
      | i64_binop_fini

      break;
    case PWASM_OP_I64_DIV_U:
      | i64_binop_init
      | mov rdx, 0    // zero-extend into edx
      | div rbx       // unsigned divide
      | i64_binop_fini

      break;
    case PWASM_OP_I64_REM_S:
      | i64_binop_init
      | cqo           // sign-extend eax into edx
      | idiv rbx      // signed divide
      | mov rax, rdx  // save remainder
      | i64_binop_fini

      break;
    case PWASM_OP_I64_REM_U:
      | i64_binop_init
      | mov rdx, 0    // zero edx
      | div rbx       // unsigned divide
      | mov rax, rdx  // save remainder
      | i64_binop_fini

      break;
    case PWASM_OP_I64_AND:
      | i64_binop_init
      | and rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_OR:
      | i64_binop_init
      | or rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_XOR:
      | i64_binop_init
      | xor rax, rbx
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SHL:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | shl rax, cl   // shift left
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SHR_S:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | sar rax, cl   // shift right (arithmetic)
      | i64_binop_fini

      break;
    case PWASM_OP_I64_SHR_U:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | shr rax, cl   // shift right (logical)
      | i64_binop_fini

      break;
    case PWASM_OP_I64_ROTL:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | rol rax, cl   // rotate left
      | i64_binop_fini

      break;
    case PWASM_OP_I64_ROTR:
      | i64_binop_init
      | mov cl, bl    // move shift to cl
      | ror rax, cl   // rotate right
      | i64_binop_fini

      break;
    default:
      {
        // log error
        char buf[512];
        snprintf(buf, sizeof(buf), "unimplemented opcode: 0x%08x", in.op);
        fail(env, buf);

        // return failure
        return false;
      }
    }
  }

  // emit exit_success
  | ->exit_success:

  // save stack depth
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | add rax, offsetof(pwasm_stack_t, pos)
  | add qword [rax], type.results.len

  // return success
  | mov rax, 1
  | ret

  // emit exit_failure
  | ->exit_failure:
  | mov rax, 0
  | ret

  // get needed size
  size_t num_bytes;
  if (dasm_link(&dasm, &num_bytes)) {
    fail(env, "dasm_link() failed");
    return false;
  }

  // map memory, check for error
  void *ptr = mmap(NULL, num_bytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (!ptr) {
    // log error, return failure
    fail(env, "dasm_link() failed");
    return false;
  }

  // encode, check for error
  if (dasm_encode(&dasm, ptr)) {
    // log error, return failure
    fail(env, "dasm_encode() failed");
    return false;
  }

  // finalize dynasm state
  dasm_free(&dasm);

  // finalize control stack
  pwasm_ctrl_stack_fini(&ctrl_stack);

  // protect memory
  if (mprotect(ptr, num_bytes, PROT_READ | PROT_EXEC)) {
    // log error, return failure
    fail(env, "mprotect() failed");
    return false;
  }

  // populate result
  D("dst = %p, buf = { 0x%p, %zu }", (void*) dst, ptr, num_bytes);
  dst->ptr = ptr;
  dst->len = num_bytes;

  // dump buffer
  pwasm_dump(env, mod_id, func_ofs, *dst);

  // return success
  return true;
}

// vi: syntax=c
