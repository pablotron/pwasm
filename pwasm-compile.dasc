/**
 * pwasm_compile(): JIT compiler for PWASM module functions implemented
 * via DynASM.
 */
#include <stdbool.h> // bool
#include <stdio.h> // snprintf()
#include <sys/mman.h> // mprotect
#include "pwasm-compile.h"
#include <dynasm/dasm_proto.h>
#include <dynasm/dasm_x86.h>

#ifdef PWASM_DEBUG
#include <stdio.h>
#define D(fmt, ...) fprintf( \
  stderr, \
  "D %s:%d %s(): " fmt "\n", \
  __FILE__, __LINE__, __func__, __VA_ARGS__ \
)
#else
#define D(fmt, ...)
#endif /* PWASM_DEBUG */

|.arch x64
|.actionlist actions
|.globals lbl_

// function args
// sysv amd64 calling convention
// (https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions)
|.define r_arg0, rdi
|.define r_arg1, rsi
|.define r_arg2, rdx

// pointer to base and tail of stack
|.define r_env, r12
|.define r_base, r13
|.define r_stack, r14

// TODO
|.macro epilogue
  | nop
|.endmacro

|.macro stack_inc
  | add r_stack, sizeof(pwasm_val_t)
|.endmacro

|.macro stack_dec
  | sub r_stack, sizeof(pwasm_val_t)
|.endmacro

|.macro stack_decn, num
  | sub r_stack, (num * sizeof(pwasm_val_t))
|.endmacro

/**
 * Call error handler.
 */
static void
fail(
  pwasm_env_t * const env,
  const char * const text
) {
  D("%s", text);
  pwasm_fail(env->mem_ctx, text);
}

//
// control stack: used by compiler to manage control frames
//

// control stack entry types
#define CTRL_TYPES \
  CTRL_TYPE(BLOCK) \
  CTRL_TYPE(LOOP) \
  CTRL_TYPE(IF) \
  CTRL_TYPE(ELSE)

// control stack entry types
typedef enum {
#define CTRL_TYPE(a) CTRL_ ## a,
CTRL_TYPES
#undef CTRL_TYPE
  CTRL_LAST,
} pwasm_ctrl_stack_entry_type_t;

// control stack entry
typedef struct {
  pwasm_ctrl_stack_entry_type_t type; // entry type
  int32_t block_type; // block type
  size_t label;
} pwasm_ctrl_stack_entry_t;

// control stack
typedef struct {
  // vector of entries
  pwasm_vec_t stack;
} pwasm_ctrl_stack_t;

/**
 * Initialize control stack.
 *
 * Returns `true` on success or `false` on error.
 */
static bool
pwasm_ctrl_stack_init(
  pwasm_ctrl_stack_t * const stack,
  pwasm_mem_ctx_t * const mem_ctx
) {
  const size_t stride = sizeof(pwasm_ctrl_stack_entry_t);
  return pwasm_vec_init(mem_ctx, &(stack->stack), stride);
}

/**
 * Finalize control stack.
 */
static void
pwasm_ctrl_stack_fini(
  pwasm_ctrl_stack_t * const stack
) {
  pwasm_vec_fini(&(stack->stack));
}

#if 0
static size_t
pwasm_ctrl_stack_get_size(
  const pwasm_ctrl_stack_t * const stack
) {
  return pwasm_vec_get_size(&(stack->stack));
}
#endif /* 0 */

static const void *
pwasm_ctrl_stack_peek_tail(
  const pwasm_ctrl_stack_t * const stack,
  const size_t ofs
) {
  return pwasm_vec_peek_tail(&(stack->stack), ofs);
}

/**
 * Remove tail entry from control stack.
 *
 * Returns `false` if an error occurred.
 */
static bool
pwasm_ctrl_stack_pop(
  pwasm_ctrl_stack_t * const stack,
  pwasm_ctrl_stack_entry_t * const dst
) {
  // pop final entry, return result
  return pwasm_vec_pop(&(stack->stack), dst);
}

/**
 * Append entry to tail of control stack.
 *
 * Returns `false` if an error occurred.
 */
static bool
pwasm_ctrl_stack_push(
  pwasm_ctrl_stack_t * const stack,
  const pwasm_ctrl_stack_entry_t entry
) {
  return pwasm_vec_push(&(stack->stack), 1, &entry, NULL);
}

/**
 * Compile the given module function and then populate the given
 * destination buffer with the length of the generated code and a
 * pointer to the start of the function.
 *
 * Returns `true` on success, or `false` if an error occurred.
 */
bool
pwasm_compile(
  pwasm_buf_t * const dst,
  pwasm_env_t *env,
  const uint32_t mod_id,
  const pwasm_mod_t *mod,
  const size_t func_ofs
) {
  const pwasm_type_t type = mod->types[mod->funcs[func_ofs]];
  const pwasm_func_t func = mod->codes[func_ofs];
  const pwasm_inst_t * const insts = mod->insts + func.expr.ofs;

  // init control stack
  size_t ctrl_depth = 0;
  pwasm_ctrl_stack_t ctrl_stack;
  if (!pwasm_ctrl_stack_init(&ctrl_stack, env->mem_ctx)) {
    fail(env, "ctrl_stack_init failed");
    return false;
  }

  // init jit
  void *labels[lbl__MAX];
  dasm_State *dasm;
  D("dasm_init(%u)", 1);
  dasm_init(&dasm, 1);
  dasm_setupglobal(&dasm, labels, lbl__MAX);
  dasm_setup(&dasm, actions);
  dasm_growpc(&dasm, 100); // FIXME

  dasm_State** Dst = &dasm;
  | ->enter: // FIXME: add prologue
  // get env pointer
  | mov r_env, r_arg0

  // get stack pointer from env
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | mov r_stack, [rax + offsetof(pwasm_stack_t, ptr)]

  // get stack offset
  | imul rbx, [rax + offsetof(pwasm_stack_t, pos)], sizeof(pwasm_val_t)

  // increment stack pointer
  | add r_stack, rbx
  | mov r_base, r_stack

  size_t max_label = 0;
  for (size_t i = 0; i < func.expr.len; i++) {
    const pwasm_inst_t in = insts[i];
    switch (in.op) {
    case PWASM_OP_I32_CONST:
      D("0x%02X %s (0x%08x)", in.op, pwasm_op_get_name(in.op), in.v_i32);
      break;
    default:
      D("0x%02X %s", in.op, pwasm_op_get_name(in.op));
    }

    switch (in.op) {
    case PWASM_OP_UNREACHABLE:
      {
        // log error message (FIXME)
        // const char * const err = "unreachable";
        // | mov r_arg0, env
        // | mov r_arg1, err
        // | call aword fail

        // return failure
        | jmp ->exit_failure
      }
      break;
    case PWASM_OP_NOP:
      | nop
      break;
    case PWASM_OP_BLOCK:
      {
        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "block: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // decriment stack (block parameters)
          | stack_decn num_params
        }

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_BLOCK,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "block: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label++;
        dasm_growpc(&dasm, max_label);
      }

      break;
    case PWASM_OP_LOOP:
      {
        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "loop: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // decriment stack (block parameters)
          | stack_decn num_params
        }

        // emit label
        |=>max_label:

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_LOOP,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "loop: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label++;
        dasm_growpc(&dasm, max_label);
      }

      break;
    case PWASM_OP_IF:
      {
        // emit condition pop
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | stack_dec

        // create control stack entry
        const pwasm_ctrl_stack_entry_t entry = {
          .type       = CTRL_IF,
          .block_type = in.v_block.block_type,
          .label      = max_label,
        };

        // push entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, entry)) {
          fail(env, "if: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        ctrl_depth++;

        // increment label
        max_label += 2;
        dasm_growpc(&dasm, max_label);

        // emit compare
        | cmp eax, 0
        | je =>entry.label

        // get block.params.size, check for error
        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, in.v_block.block_type, &num_params)) {
          // log error, return failure
          fail(env, "if: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // emit stack pop (block parameters)
          D("num_params = %zu", num_params);
          // FIXME
          // | stack_decn num_params
        }
      }

      break;
    case PWASM_OP_ELSE:
      {
        // pop if entry, check for error
        pwasm_ctrl_stack_entry_t if_entry;
        if (!pwasm_ctrl_stack_pop(&ctrl_stack, &if_entry)) {
          fail(env, "else: ctrl_stack_pop failed");
          return false;
        }

        // decriment control depth
        // disabled, redundant
        // ctrl_depth--;

        // emit unconditional jump to end
        | jmp =>(if_entry.label + 1)
        // emit else label
        | =>(if_entry.label):

        size_t num_params;
        if (!pwasm_block_type_params_get_size(mod, if_entry.block_type, &num_params)) {
          // log error, return failure
          fail(env, "if: get num block params failed");
          return false;
        }

        if (num_params > 0) {
          // emit stack pop (block parameters)
          D("num_params = %zu", num_params);
          | stack_decn num_params
        }

        // create control stack entry
        const pwasm_ctrl_stack_entry_t else_entry = {
          .type       = CTRL_ELSE,
          .block_type = if_entry.block_type,
          .label      = if_entry.label + 1,
        };

        // push else entry, check for error
        if (!pwasm_ctrl_stack_push(&ctrl_stack, else_entry)) {
          fail(env, "else: ctrl_stack_push failed");
          return false;
        }

        // increment control depth
        // disabled, redundant
        // ctrl_depth++;
      }

      break;
    case PWASM_OP_END:
      if (ctrl_depth > 0) {
        // pop control stack, check for error
        pwasm_ctrl_stack_entry_t tail;
        if (!pwasm_ctrl_stack_pop(&ctrl_stack, &tail)) {
          fail(env, "ctrl_stack_pop failed");
          return false;
        }

        // decriment depth
        ctrl_depth--;

        switch (tail.type) {
        case CTRL_IF:
          // emit tail labels
          // FIXME: is this right?
          | =>(tail.label):
          | =>(tail.label + 1):
          break;
        case CTRL_ELSE:
        case CTRL_BLOCK:
          // emit tail label
          | =>(tail.label):
          break;
        case CTRL_LOOP:
          // do nothing
          break;
        default:
          {
            // log error
            char buf[512];
            snprintf(buf, sizeof(buf), "unknown ctrl stack entry type: %u", tail.type);
            fail(env, buf);

            // return failure
            return false;
          }
        }

        // get block type result count, check for error
        size_t num_results;
        if (!pwasm_block_type_results_get_size(mod, tail.block_type, &num_results)) {
          // log error, return failure
          fail(env, "end: get block num_results failed");
          return false;
        }

        // pop results
        // TODO
//         for (size_t j = 0; j < num_results; j++) {
//           // calculate stack source and destination offsets
//           const size_t src_ofs = stack->pos - 1 - (num_results - 1 - j);
//           const size_t dst_ofs = ctrl_tail.depth + j;
//           stack->ptr[dst_ofs] = stack->ptr[src_ofs];
//         }
      } else {
        | jmp ->exit_success
      }

      break;
    case PWASM_OP_BR:
      if ((ctrl_depth > 0) && (ctrl_depth - in.v_index) > 0) {
        // get control stack tail, check for error
        const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, in.v_index);
        if (!tail) {
          fail(env, "br: ctrl_stack_peek_tail failed");
          return false;
        }

        // get destination label
        const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

        // emit jump to label
        | jmp =>label
      } else {
        // emit exit success
        | jmp ->exit_success
      }

      break;
    case PWASM_OP_BR_IF:
      // emit compare
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | stack_dec
      | cmp eax, 0

      if ((ctrl_depth > 0) && (ctrl_depth - in.v_index) > 0) {
        // get control stack tail, check for error
        const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, in.v_index);
        if (!tail) {
          fail(env, "br: ctrl_stack_peek_tail failed");
          return false;
        }

        // get destination label
        const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

        // emit jump to label
        | je =>label
      } else {
        // emit exit success
        | je ->exit_success
      }

      break;
    case PWASM_OP_BR_TABLE:
      {
        // get branch labels
        const pwasm_slice_t labels = in.v_br_table;

        // pop index
        | mov eax, [r_stack - sizeof(pwasm_val_t)]
        | stack_dec

        // emit labels
        // FIXME: this could be optimized into a jump table
        for (size_t j = 0; j < labels.len - 1; j++) {
          const uint32_t ofs = mod->u32s[labels.ofs + j];

          if ((ctrl_depth > 0) && (ctrl_depth - ofs) > 0) {
            const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, ofs);
            if (!tail) {
              fail(env, "br_table: ctrl_stack_peek_tail failed");
              return false;
            }

            // get destination label
            const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

            // emit conditional jump
            | cmp eax, j
            | je =>label
          } else {
            // emit exit success
            | cmp eax, j
            | je ->exit_success
          }
        }

        // emit unconditional jump to default label
        {
          // get offset of last branch target
          const uint32_t ofs = mod->u32s[labels.ofs + labels.len - 1];

          if ((ctrl_depth > 0) && (ctrl_depth - ofs) > 0) {
            const pwasm_ctrl_stack_entry_t *tail = pwasm_ctrl_stack_peek_tail(&ctrl_stack, ofs);
            if (!tail) {
              fail(env, "br_table: ctrl_stack_peek_tail failed");
              return false;
            }

            // get destination label
            const size_t label = tail->label + ((tail->type == CTRL_IF) ? 1 : 0);

            // emit unconditional jump to default label
            | jmp =>label
          } else {
            // emit unconditional jump to exit_success
            | jmp ->exit_success
          }
        }
      }

      break;
    case PWASM_OP_RETURN:
      // emit unconditional jump to exit_success
      | jmp ->exit_success

      break;
    case PWASM_OP_CALL:
      // TODO: emit store stack position, push registers
      | mov r_arg0, env
      | mov r_arg1, mod
      | mov r_arg2, in.v_index
      // TODO: | call aword pwasm_aot_jit_call_func
      | cmp eax, 0
      | je ->exit_failure
      // TODO: pop registers, restore stack position

      break;
    // TODO: case PWASM_OP_CALL_INDIRECT:
    case PWASM_OP_DROP:
      | stack_dec

      break;
    case PWASM_OP_SELECT:
      // pop value, compare to zero
      | mov eax, [r_stack - sizeof(pwasm_val_t)]
      | cmp eax, 0

      // get left value (FIXME: use xmm?)
      | cmovnz rax, [r_stack - 3 * sizeof(pwasm_val_t)]
      | cmovnz rbx, [r_stack - 3 * sizeof(pwasm_val_t) + sizeof(uint64_t)]

      // get right value (FIXME: use xmm?)
      | cmovz rax, [r_stack - 2 * sizeof(pwasm_val_t)]
      | cmovz rbx, [r_stack - 2 * sizeof(pwasm_val_t) + sizeof(uint64_t)]

      // store result
      | mov [r_stack - 3 * sizeof(pwasm_val_t)], rax
      | mov [r_stack - 3 * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx

      // decriment stack
      | stack_decn 2

      break;
    case PWASM_OP_LOCAL_GET:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_base - ofs * sizeof(pwasm_val_t)]
        | mov rbx, [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_stack], rax
        | mov [r_stack + sizeof(uint64_t)], rbx
        | stack_inc
      }

      break;
    case PWASM_OP_LOCAL_SET:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_base - ofs * sizeof(pwasm_val_t)], rax
        | mov [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
        | stack_dec
      }

      break;
    case PWASM_OP_LOCAL_TEE:
      {
        const size_t ofs = func.frame_size - in.v_index;

        | mov rax, [r_stack - sizeof(pwasm_val_t)]
        | mov rbx, [r_stack - sizeof(pwasm_val_t) + sizeof(uint64_t)]
        | mov [r_base - ofs * sizeof(pwasm_val_t)], rax
        | mov [r_base - ofs * sizeof(pwasm_val_t) + sizeof(uint64_t)], rbx
      }

      break;
    case PWASM_OP_I32_CONST:
      | mov dword [r_stack], in.v_i32
      | stack_inc

      break;
    case PWASM_OP_I32_ADD:
      | mov eax, [r_stack - 2 * sizeof(pwasm_val_t)]
      | mov ebx, [r_stack - sizeof(pwasm_val_t)]
      | add eax, ebx
      | mov [r_stack - 2 * sizeof(pwasm_val_t)], eax
      | stack_dec

      break;
    case PWASM_OP_I32_SUB:
      | mov eax, dword [r_stack - 2 * sizeof(pwasm_val_t)]
      | mov ebx, dword [r_stack - sizeof(pwasm_val_t)]
      | sub eax, ebx
      | mov dword [r_stack - 2 * sizeof(pwasm_val_t)], eax
      | stack_dec

      break;
    case PWASM_OP_I64_CONST:
      | mov qword [r_stack], in.v_i64
      | stack_inc

      break;
    case PWASM_OP_I64_ADD:
      | mov rax, [r_stack - 2 * sizeof(pwasm_val_t)]
      | mov rbx, [r_stack - sizeof(pwasm_val_t)]
      | add rax, rbx
      | mov [r_stack - 2 * sizeof(pwasm_val_t)], rax
      | stack_dec

      break;
    default:
      {
        // log error
        char buf[512];
        snprintf(buf, sizeof(buf), "unimplemented opcode: 0x%08x", in.op);
        fail(env, buf);

        // return failure
        return false;
      }
    }
  }

  // emit exit_success
  | ->exit_success:

  // save stack depth
  | mov rax, [r_env + offsetof(pwasm_env_t, stack)]
  | add rax, offsetof(pwasm_stack_t, pos)
  | add qword [rax], type.results.len

  // return success
  | epilogue
  | mov rax, 1
  | ret

  // emit exit_failure
  | ->exit_failure:
  | epilogue
  | mov rax, 0
  | ret

  // get needed size
  size_t num_bytes;
  if (dasm_link(&dasm, &num_bytes)) {
    fail(env, "dasm_link() failed");
    return false;
  }

  // map memory, check for error
  void *ptr = mmap(NULL, num_bytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (!ptr) {
    // log error, return failure
    fail(env, "dasm_link() failed");
    return false;
  }

  // encode, check for error
  if (dasm_encode(&dasm, ptr)) {
    // log error, return failure
    fail(env, "dasm_encode() failed");
    return false;
  }

  // finalize dynasm state
  dasm_free(&dasm);

  // finalize control stack
  pwasm_ctrl_stack_fini(&ctrl_stack);

  // protect memory
  if (mprotect(ptr, num_bytes, PROT_READ | PROT_EXEC)) {
    // log error, return failure
    fail(env, "mprotect() failed");
    return false;
  }

  // populate result
  D("dst = %p, buf = { 0x%p, %zu }", (void*) dst, ptr, num_bytes);
  dst->ptr = ptr;
  dst->len = num_bytes;

  // return success
  return true;
}

// vi: syntax=c
