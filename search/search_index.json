{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About PWASM (pronounced \"possum\") is a command-line tool and library for handling WebAssembly modules. The pwasm command lets you inspect and disassemble WebAssembly modules. Learn more . The PWASM library allows you to parse WebAssembly modules and and execute functions from WebAssembly modules inside your application. Learn more .","title":"About"},{"location":"#about","text":"PWASM (pronounced \"possum\") is a command-line tool and library for handling WebAssembly modules. The pwasm command lets you inspect and disassemble WebAssembly modules. Learn more . The PWASM library allows you to parse WebAssembly modules and and execute functions from WebAssembly modules inside your application. Learn more .","title":"About"},{"location":"command/","text":"Command Overview The pwasm command lets you inspect and disassemble WebAssembly modules. Features The pwasm tool can: Disassemble WebAssembly modules into WebAssembly Text (WAT) files. Extract the data from custom sections of WebAssembly modules. Run the built-in test suite. Usage Use the pwasm help command for a list of command-line options: > pwasm help Usage: pwasm <command> [args] Commands: help: Show help. Use \"help <command>\" for help on a command. test: Run tests. wat: Convert one or more WASM files to WAT files. list-custom: List custom sections in WASM file. cat-custom: Extract custom section from WASM file. Example Here's an example which uses the pwasm command-line tool to disassemble a WebAssembly module named 03-mem.wasm into WebAssembly text (WAT) format. > pwasm wat ./03-mem.wasm (module (memory $m0 1) (func $f0 (param $v0 i32) (result i32) (local.get $v0) (i32.load) ) (func $f1 (param $v0 i32) (param $v1 i32) (result i32) (local.get $v0) (local.get $v1) (i32.store) (local.get $v1) ) (export \"mem\" (memory $m0)) (export \"get\" (func $f0)) (export \"set\" (func $f1)))","title":"Command"},{"location":"command/#command","text":"","title":"Command"},{"location":"command/#overview","text":"The pwasm command lets you inspect and disassemble WebAssembly modules.","title":"Overview"},{"location":"command/#features","text":"The pwasm tool can: Disassemble WebAssembly modules into WebAssembly Text (WAT) files. Extract the data from custom sections of WebAssembly modules. Run the built-in test suite.","title":"Features"},{"location":"command/#usage","text":"Use the pwasm help command for a list of command-line options: > pwasm help Usage: pwasm <command> [args] Commands: help: Show help. Use \"help <command>\" for help on a command. test: Run tests. wat: Convert one or more WASM files to WAT files. list-custom: List custom sections in WASM file. cat-custom: Extract custom section from WASM file.","title":"Usage"},{"location":"command/#example","text":"Here's an example which uses the pwasm command-line tool to disassemble a WebAssembly module named 03-mem.wasm into WebAssembly text (WAT) format. > pwasm wat ./03-mem.wasm (module (memory $m0 1) (func $f0 (param $v0 i32) (result i32) (local.get $v0) (i32.load) ) (func $f1 (param $v0 i32) (param $v1 i32) (result i32) (local.get $v0) (local.get $v1) (i32.store) (local.get $v1) ) (export \"mem\" (memory $m0)) (export \"get\" (func $f0)) (export \"set\" (func $f1)))","title":"Example"},{"location":"library/","text":"Library Overview The PWASM library allows you to parse WebAssembly modules and and run functions from WebAssembly modules inside your application. Features The PWASM library has the following features: Easy to embed. Two files: pwasm.c and pwasm.h . Supports isolated execution environments. Built-in interpreter which should run just about anywhere. Modular architecture. Use the parser and ignore the interpreter, write your own JIT , etc. No dependencies other than the C standard library . Customizable memory allocator. Parser uses amortized O(1) memory allocation. \"Native\" module support. Call native functions from a WebAssembly module. Written in modern C11 . MIT-licensed . Coming Soon JIT and AOT compiler. Threaded parser. Vector instruction extension. Usage PWASM is meant to be embedded in an existing application. Here's how: Copy pwasm.h and pwasm.c into the source directory of an existing application. Add pwasm.c to your build. Link against -lm . To execute functions from a WebAssembly module, do the following: Create a PWASM memory context. Read the contents of the module. Parse the module with pwasm_mod_init() . Create an interpreter environment with pwasm_env_init() . Add the parsed module into the environment with pwasm_env_add_mod() . Call module functions with pwasm_call() . Example The example below does the following: Parses a WebAssembly module. Creates an interpreter environment. Adds the parsed module to the interpreter. Executes the f32.pythag() module function. Prints the result to standard output. Executes f64.pythag() module function. Prints the result to standard output. Finalizes the interpreter and the parsed module. /** * example-00-pythag.c: minimal standalone pwasm example. * * Usage: * # compile 00-pythag.c and pwasm.c * cc -c -W -Wall -Wextra -Werror -pedantic -std=c11 -I. -O3 examples/example-00-pythag.c * cc -c -W -Wall -Wextra -Werror -pedantic -std=c11 -I. -O3 pwasm.c * * # link and build as ./example-00-pythag * cc -o ./example-00-pythag {00-pythag,pwasm}.o -lm * * Output: * # run example-00-pythag * > ./example-00-pythag * f32.pythag(3.0, 4.0) = 5.000000 * f64.pythag(5.0, 6.0) = 7.810250 * */ #include <stdlib.h> // EXIT_FAILURE #include <stdio.h> // printf() #include <stdint.h> // uint8_t, etc #include <err.h> // errx() #include <pwasm.h> /** * Blob containing a small WebAssembly (WASM) module. * * This WASM module exports two functions: * * * f32.pythag (f32, f32 -> f32): Calculate the length of the * hypotenuse of a right triangle from the lengths of the other * two sides of the triangle. * * * f64.pythag (f64, f64 -> f64): Calculate the length of the * hypotenuse of a right triangle from the lengths of the other * two sides of the triangle. */ static const uint8_t PYTHAG_WASM [] = { 0x00 , 0x61 , 0x73 , 0x6d , 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x0D , 0x02 , 0x60 , 0x02 , 0x7E , 0x7E , 0x01 , 0x7E , 0x60 , 0x02 , 0x7C , 0x7C , 0x01 , 0x7C , 0x03 , 0x03 , 0x02 , 0x00 , 0x01 , 0x07 , 0x1B , 0x02 , 0x0A , 'f' , '3' , '2' , '.' , 'p' , 'y' , 't' , 'h' , 'a' , 'g' , 0x00 , 0x00 , 0x0A , 'f' , '6' , '4' , '.' , 'p' , 'y' , 't' , 'h' , 'a' , 'g' , 0x00 , 0x01 , 0x0A , 0x1F , 0x02 , 0x0E , 0x00 , 0x20 , 0x00 , 0x20 , 0x00 , 0x94 , 0x20 , 0x01 , 0x20 , 0x01 , 0x94 , 0x92 , 0x91 , 0x0B , 0x0E , 0x00 , 0x20 , 0x00 , 0x20 , 0x00 , 0xA2 , 0x20 , 0x01 , 0x20 , 0x01 , 0xA2 , 0xA0 , 0x9F , 0x0B , }; static void test_f32_pythag ( pwasm_env_t * const env , pwasm_stack_t * const stack ) { // set parameters values and parameter count stack -> ptr [ 0 ]. f32 = 3 ; stack -> ptr [ 1 ]. f32 = 4 ; stack -> pos = 2 ; // call function \"f32.pythag\" in the \"pythag\" module, check for error if ( ! pwasm_call ( env , \"pythag\" , \"f32.pythag\" )) { errx ( EXIT_FAILURE , \"f32.pythag: pwasm_call() failed\" ); } // print result (the first stack entry) to standard output printf ( \"f32.pythag(3.0, 4.0) = %f \\n \" , stack -> ptr [ 0 ]. f32 ); } static void test_f64_pythag ( pwasm_env_t * const env , pwasm_stack_t * const stack ) { // set parameters stack -> ptr [ 0 ]. f64 = 5 ; stack -> ptr [ 1 ]. f64 = 6 ; stack -> pos = 2 ; // call function, check for error if ( ! pwasm_call ( env , \"pythag\" , \"f64.pythag\" )) { errx ( EXIT_FAILURE , \"f64.pythag: pwasm_call() failed\" ); } // print result (the first stack entry) to standard output printf ( \"f64.pythag(5.0, 6.0) = %f \\n \" , stack -> ptr [ 0 ]. f64 ); } int main ( void ) { // create a memory context pwasm_mem_ctx_t mem_ctx = pwasm_mem_ctx_init_defaults ( NULL ); pwasm_mod_t mod ; { // wrap pythag.wasm data in buffer pwasm_buf_t buf = { PYTHAG_WASM , sizeof ( PYTHAG_WASM ) }; // parse module, check for error if ( ! pwasm_mod_init ( & mem_ctx , & mod , buf )) { errx ( EXIT_FAILURE , \"pwasm_mod_init() failed\" ); } } // set up stack (used to pass parameters and results and // to execute the stack machine inside functions) pwasm_val_t stack_vals [ 10 ]; pwasm_stack_t stack = { . ptr = stack_vals , . len = 10 , }; // get interpreter callbacks const pwasm_env_cbs_t * const interp_cbs = pwasm_new_interpreter_get_cbs (); // create interpreter environment, check for error pwasm_env_t env ; if ( ! pwasm_env_init ( & env , & mem_ctx , interp_cbs , & stack , NULL )) { errx ( EXIT_FAILURE , \"pwasm_env_init() failed\" ); } // add parsed module to interpreter environment with a // name of \"pythag\", check for error if ( ! pwasm_env_add_mod ( & env , \"pythag\" , & mod )) { errx ( EXIT_FAILURE , \"pythag: pwasm_env_add_mod() failed\" ); } // call \"f32.pythag\" function test_f32_pythag ( & env , & stack ); // call \"f64.pythag\" function test_f64_pythag ( & env , & stack ); // finalize interpreter environment and parsed module pwasm_env_fini ( & env ); pwasm_mod_fini ( & mod ); // return success return EXIT_SUCCESS ; }","title":"Library"},{"location":"library/#library","text":"","title":"Library"},{"location":"library/#overview","text":"The PWASM library allows you to parse WebAssembly modules and and run functions from WebAssembly modules inside your application.","title":"Overview"},{"location":"library/#features","text":"The PWASM library has the following features: Easy to embed. Two files: pwasm.c and pwasm.h . Supports isolated execution environments. Built-in interpreter which should run just about anywhere. Modular architecture. Use the parser and ignore the interpreter, write your own JIT , etc. No dependencies other than the C standard library . Customizable memory allocator. Parser uses amortized O(1) memory allocation. \"Native\" module support. Call native functions from a WebAssembly module. Written in modern C11 . MIT-licensed . Coming Soon JIT and AOT compiler. Threaded parser. Vector instruction extension.","title":"Features"},{"location":"library/#usage","text":"PWASM is meant to be embedded in an existing application. Here's how: Copy pwasm.h and pwasm.c into the source directory of an existing application. Add pwasm.c to your build. Link against -lm . To execute functions from a WebAssembly module, do the following: Create a PWASM memory context. Read the contents of the module. Parse the module with pwasm_mod_init() . Create an interpreter environment with pwasm_env_init() . Add the parsed module into the environment with pwasm_env_add_mod() . Call module functions with pwasm_call() .","title":"Usage"},{"location":"library/#example","text":"The example below does the following: Parses a WebAssembly module. Creates an interpreter environment. Adds the parsed module to the interpreter. Executes the f32.pythag() module function. Prints the result to standard output. Executes f64.pythag() module function. Prints the result to standard output. Finalizes the interpreter and the parsed module. /** * example-00-pythag.c: minimal standalone pwasm example. * * Usage: * # compile 00-pythag.c and pwasm.c * cc -c -W -Wall -Wextra -Werror -pedantic -std=c11 -I. -O3 examples/example-00-pythag.c * cc -c -W -Wall -Wextra -Werror -pedantic -std=c11 -I. -O3 pwasm.c * * # link and build as ./example-00-pythag * cc -o ./example-00-pythag {00-pythag,pwasm}.o -lm * * Output: * # run example-00-pythag * > ./example-00-pythag * f32.pythag(3.0, 4.0) = 5.000000 * f64.pythag(5.0, 6.0) = 7.810250 * */ #include <stdlib.h> // EXIT_FAILURE #include <stdio.h> // printf() #include <stdint.h> // uint8_t, etc #include <err.h> // errx() #include <pwasm.h> /** * Blob containing a small WebAssembly (WASM) module. * * This WASM module exports two functions: * * * f32.pythag (f32, f32 -> f32): Calculate the length of the * hypotenuse of a right triangle from the lengths of the other * two sides of the triangle. * * * f64.pythag (f64, f64 -> f64): Calculate the length of the * hypotenuse of a right triangle from the lengths of the other * two sides of the triangle. */ static const uint8_t PYTHAG_WASM [] = { 0x00 , 0x61 , 0x73 , 0x6d , 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x0D , 0x02 , 0x60 , 0x02 , 0x7E , 0x7E , 0x01 , 0x7E , 0x60 , 0x02 , 0x7C , 0x7C , 0x01 , 0x7C , 0x03 , 0x03 , 0x02 , 0x00 , 0x01 , 0x07 , 0x1B , 0x02 , 0x0A , 'f' , '3' , '2' , '.' , 'p' , 'y' , 't' , 'h' , 'a' , 'g' , 0x00 , 0x00 , 0x0A , 'f' , '6' , '4' , '.' , 'p' , 'y' , 't' , 'h' , 'a' , 'g' , 0x00 , 0x01 , 0x0A , 0x1F , 0x02 , 0x0E , 0x00 , 0x20 , 0x00 , 0x20 , 0x00 , 0x94 , 0x20 , 0x01 , 0x20 , 0x01 , 0x94 , 0x92 , 0x91 , 0x0B , 0x0E , 0x00 , 0x20 , 0x00 , 0x20 , 0x00 , 0xA2 , 0x20 , 0x01 , 0x20 , 0x01 , 0xA2 , 0xA0 , 0x9F , 0x0B , }; static void test_f32_pythag ( pwasm_env_t * const env , pwasm_stack_t * const stack ) { // set parameters values and parameter count stack -> ptr [ 0 ]. f32 = 3 ; stack -> ptr [ 1 ]. f32 = 4 ; stack -> pos = 2 ; // call function \"f32.pythag\" in the \"pythag\" module, check for error if ( ! pwasm_call ( env , \"pythag\" , \"f32.pythag\" )) { errx ( EXIT_FAILURE , \"f32.pythag: pwasm_call() failed\" ); } // print result (the first stack entry) to standard output printf ( \"f32.pythag(3.0, 4.0) = %f \\n \" , stack -> ptr [ 0 ]. f32 ); } static void test_f64_pythag ( pwasm_env_t * const env , pwasm_stack_t * const stack ) { // set parameters stack -> ptr [ 0 ]. f64 = 5 ; stack -> ptr [ 1 ]. f64 = 6 ; stack -> pos = 2 ; // call function, check for error if ( ! pwasm_call ( env , \"pythag\" , \"f64.pythag\" )) { errx ( EXIT_FAILURE , \"f64.pythag: pwasm_call() failed\" ); } // print result (the first stack entry) to standard output printf ( \"f64.pythag(5.0, 6.0) = %f \\n \" , stack -> ptr [ 0 ]. f64 ); } int main ( void ) { // create a memory context pwasm_mem_ctx_t mem_ctx = pwasm_mem_ctx_init_defaults ( NULL ); pwasm_mod_t mod ; { // wrap pythag.wasm data in buffer pwasm_buf_t buf = { PYTHAG_WASM , sizeof ( PYTHAG_WASM ) }; // parse module, check for error if ( ! pwasm_mod_init ( & mem_ctx , & mod , buf )) { errx ( EXIT_FAILURE , \"pwasm_mod_init() failed\" ); } } // set up stack (used to pass parameters and results and // to execute the stack machine inside functions) pwasm_val_t stack_vals [ 10 ]; pwasm_stack_t stack = { . ptr = stack_vals , . len = 10 , }; // get interpreter callbacks const pwasm_env_cbs_t * const interp_cbs = pwasm_new_interpreter_get_cbs (); // create interpreter environment, check for error pwasm_env_t env ; if ( ! pwasm_env_init ( & env , & mem_ctx , interp_cbs , & stack , NULL )) { errx ( EXIT_FAILURE , \"pwasm_env_init() failed\" ); } // add parsed module to interpreter environment with a // name of \"pythag\", check for error if ( ! pwasm_env_add_mod ( & env , \"pythag\" , & mod )) { errx ( EXIT_FAILURE , \"pythag: pwasm_env_add_mod() failed\" ); } // call \"f32.pythag\" function test_f32_pythag ( & env , & stack ); // call \"f64.pythag\" function test_f64_pythag ( & env , & stack ); // finalize interpreter environment and parsed module pwasm_env_fini ( & env ); pwasm_mod_fini ( & mod ); // return success return EXIT_SUCCESS ; }","title":"Example"}]}